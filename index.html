<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WAX TA Trading Bot</title>
    <script src="waxjs.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/7.12.1/polyfill.min.js"></script>
    <script src="trendyways.min.js"></script>

    <style>
        /* --- Base Styles --- */
        :root {
            --bg-primary: #1a1c23;
            --bg-secondary: #242731;
            --bg-tertiary: #3a3f4c;
            --border-color: #4a5160;
            --text-primary: #e0e2e8;
            --text-secondary: #a0a6b3;
            --text-cyan: #22d3ee;
            --text-green: #34d399;
            --text-red: #f87171;
            --text-yellow: #facc15;
            --text-blue: #60a5fa;
            --accent-cyan: #06b6d4;
            --accent-cyan-hover: #0891b2;
            --accent-green: #10b981;
            --accent-green-hover: #059669;
            --accent-red: #ef4444;
            --accent-red-hover: #dc2626;
            --accent-blue: #3b82f6;
            --accent-blue-hover: #2563eb;
            --shadow-color: rgba(0, 0, 0, 0.2);
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: 'Courier New', Courier, monospace;
        }

        /* --- Global Resets & Body --- */
        * { box-sizing: border-box; }
        body { background-color: var(--bg-primary); color: var(--text-primary); font-family: var(--font-sans); margin: 0; padding: 1rem; min-height: 100vh; }
        @media (min-width: 768px) { body { padding: 2rem; } }
        .container { max-width: 800px; margin: 0 auto; display: flex; flex-direction: column; gap: 1.5rem; }
        h1 { font-size: 2.25rem; font-weight: 700; text-align: center; margin: 0 0 1rem 0; color: var(--text-cyan); }
        h2 { font-size: 1.5rem; font-weight: 600; margin: 0 0 1rem 0; border-bottom: 1px solid var(--border-color); padding-bottom: 0.5rem; color: var(--text-primary); }

        /* --- App Structure --- */
        .app-section { background-color: var(--bg-secondary); padding: 1.5rem; border-radius: 8px; box-shadow: 0 4px 12px var(--shadow-color); }
        .alert { padding: 1rem; border-radius: 6px; border-left: 4px solid; }
        .alert-critical { background-color: #450a0a; border-color: var(--text-red); color: #fecaca; }
        .alert-critical p { margin: 0; }
        .alert-critical strong { color: white; font-weight: 600; }

        /* --- Forms & Inputs --- */
        fieldset { border: 1px solid var(--border-color); border-radius: 6px; padding: 1rem 1.5rem; margin-bottom: 1rem; }
        legend { padding: 0 0.5rem; font-weight: 600; color: var(--text-primary); font-size: 1.1rem; }
        .form-grid { display: grid; grid-template-columns: repeat(1, 1fr); gap: 1rem; }
        @media (min-width: 768px) { .form-grid-cols-3 { grid-template-columns: repeat(3, 1fr); } .form-grid-cols-2 { grid-template-columns: repeat(2, 1fr); } }
        .form-group { display: flex; flex-direction: column; gap: 0.25rem; }
        label { display: block; font-size: 0.875rem; font-weight: 500; color: var(--text-secondary); }
        label .default-text { font-size: 0.75rem; color: var(--text-cyan); margin-left: 0.25rem; }
        input[type="text"], input[type="number"], select { background-color: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); border-radius: 6px; padding: 0.75rem 1rem; width: 100%; transition: border-color 0.2s, box-shadow 0.2s; font-size: 0.9rem; }
        input[type="text"]:focus, input[type="number"]:focus, select:focus { outline: none; border-color: var(--accent-cyan); box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.3); }
        .note { font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.5rem; }

        /* --- Buttons --- */
        button { font-weight: 600; padding: 0.75rem 1rem; border-radius: 6px; cursor: pointer; border: none; transition: background-color 0.2s, opacity 0.2s; width: 100%; font-size: 1rem; }
        button.primary { background-color: var(--accent-cyan); color: var(--bg-primary); }
        button.primary:hover { background-color: var(--accent-cyan-hover); }
        button.secondary { background-color: var(--bg-tertiary); color: var(--text-primary); width: auto; font-size: 0.8rem; font-weight: 500; padding: 0.25rem 0.75rem; }
        button.secondary:hover { background-color: var(--border-color); }
        button.start { background-color: var(--accent-green); color: white; }
        button.start:hover { background-color: var(--accent-green-hover); }
        button.stop { background-color: var(--accent-red); color: white; }
        button.stop:hover { background-color: var(--accent-red-hover); }
        button:disabled { background-color: var(--bg-tertiary); color: var(--text-secondary); cursor: not-allowed; opacity: 0.7; }
        .button-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem; }

        /* --- Status & Log --- */
        .status-grid { margin-top: 1rem; display: flex; flex-direction: column; gap: 0.75rem; }
        .status-item { display: flex; justify-content: space-between; align-items: center; }
        .status-item .label { color: var(--text-secondary); font-size: 0.9rem; }
        .status-item .value { font-weight: 700; font-size: 1rem; }
        .status-item .value-group { display: flex; align-items: center; gap: 0.5rem; }
        #user-account { color: var(--text-green); }
        #pnl-display.positive { color: var(--text-green); }
        #pnl-display.negative { color: var(--text-red); }
        #pnl-display.neutral { color: var(--text-secondary); }
        .bot-status-container { text-align: center; }
        #bot-status { font-weight: 700; font-size: 1.1rem; }
        #bot-status.running { color: var(--text-green); }
        #bot-status.stopped { color: var(--text-red); }

        /* --- Log Output --- */
        #log-output { font-family: var(--font-mono); max-height: 400px; overflow-y: auto; background-color: var(--bg-primary); border: 1px solid var(--border-color); padding: 1rem; border-radius: 6px; font-size: 0.875rem; }
        #log-output p { margin: 0 0 0.35rem 0; border-bottom: 1px solid var(--bg-tertiary); padding-bottom: 0.35rem; word-break: break-all; line-height: 1.6; }
        #log-output p:last-child { border-bottom: none; margin-bottom: 0; }
        #log-output .log-time { color: var(--text-secondary); margin-right: 0.5rem; }
        #log-output .log-info { color: var(--text-primary); }
        #log-output .log-error { color: var(--text-red); }
        #log-output .log-success { color: var(--text-green); }
        #log-output .log-warn { color: var(--text-yellow); }
        #log-output .log-system { color: var(--text-cyan); }
        #log-output .log-idle { color: var(--text-secondary); }

        /* --- Strategy Settings --- */
        .strategy-settings.hidden { display: none; }
        hr { border: none; border-top: 1px solid var(--border-color); margin: 1.5rem 0; }

        /* --- Modal --- */
        .modal-overlay { display: none; position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.75); align-items: center; justify-content: center; z-index: 50; padding: 1rem; }
        .modal-overlay.visible { display: flex; }
        .modal-content { background-color: var(--bg-secondary); width: 100%; max-width: 500px; padding: 2rem; border-radius: 8px; box-shadow: 0 10px 30px var(--shadow-color); position: relative; }
        .modal-close-btn { position: absolute; top: 0.75rem; right: 1.25rem; color: var(--text-secondary); font-size: 2.5rem; font-weight: 300; background: none; border: none; cursor: pointer; padding: 0; width: auto; line-height: 1; }
        .modal-close-btn:hover { color: var(--text-primary); }
        .modal-content h2 { text-align: center; color: var(--text-cyan); margin-top: 0; margin-bottom: 1.5rem; border: none; }
        .modal-summary { background-color: var(--bg-tertiary); padding: 1.5rem; border-radius: 6px; margin-bottom: 1.5rem; display: flex; flex-direction: column; gap: 0.75rem; }
        .modal-summary-item { display: flex; justify-content: space-between; align-items: center; }
        .modal-summary-item .label { color: var(--text-secondary); }
        .modal-summary-item .value { font-weight: 600; }
        #share-wallet { color: var(--text-cyan); }
        #share-spent { color: var(--text-red); }
        #share-received { color: var(--text-green); }
        .modal-summary hr { margin: 0.5rem 0; }
        .modal-summary-total { font-size: 1.25rem; font-weight: 700; }
        #share-pnl.positive { color: var(--text-green); }
        #share-pnl.negative { color: var(--text-red); }
        #share-pnl.neutral { color: var(--text-secondary); }
        #copy-share-btn { background-color: var(--accent-cyan); color: var(--bg-primary); }
        #copy-share-btn:hover { background-color: var(--accent-cyan-hover); }
        #share-text { position: absolute; left: -9999px; opacity: 0; }

    </style>
</head>
<body>

    <div class="container">
        <h1>WAX TA Trading Bot</h1>

        <div class="alert alert-critical" role="alert">
            <p><strong>High Risk: Use at Your Own Risk</strong></p>
            <p>This is an educational tool. Automated trading is extremely risky and can lead to a total loss of funds. You are solely responsible for your actions. A 0.1% fee on all sell trades is sent to `qu.ug.wam`.</p>
        </div>

        <div class="app-section">
            <h2>Step 1: Connect & Status</h2>
            <button id="login-btn" class="primary">
                Login with WAX Wallet
            </button>
            <div class="status-grid">
                <div class="status-item">
                    <span class="label">Wallet:</span>
                    <strong id="user-account" class="value">Not Logged In</strong>
                </div>
                <div class="status-item">
                    <span class="label">Your PnL:</span>
                    <div class="value-group">
                        <span id="pnl-display" class="value neutral">0.00</span>
                        <button id="share-pnl-btn" class="secondary">Share</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="app-section">
            <h2>Step 2: Configure Tokens</h2>
            
            <fieldset>
                <legend>Token A (The token you want to trade)</legend>
                <div class="form-grid form-grid-cols-3">
                    <div class="form-group">
                        <label for="token-a-symbol">Symbol</label>
                        <input type="text" id="token-a-symbol" placeholder="e.g., TLM">
                    </div>
                    <div class="form-group">
                        <label for="token-a-contract">Contract</label>
                        <input type="text" id="token-a-contract" placeholder="e.g., alien.worlds">
                    </div>
                    <div class="form-group">
                        <label for="token-a-decimals">Decimals</label>
                        <input type="number" id="token-a-decimals" value="4">
                    </div>
                </div>
            </fieldset>

            <fieldset>
                <legend>Token B (e.g., WAX)</legend>
                <div class="form-grid form-grid-cols-3">
                    <div class="form-group">
                        <label for="token-b-symbol">Symbol</label>
                        <input type="text" id="token-b-symbol" placeholder="e.g., WAX" value="WAX">
                    </div>
                    <div class="form-group">
                        <label for="token-b-contract">Contract</label>
                        <input type="text" id="token-b-contract" placeholder="e.g., eosio.token" value="eosio.token">
                    </div>
                    <div class="form-group">
                        <label for="token-b-decimals">Decimals</label>
                        <input type="number" id="token-b-decimals" value="8">
                    </div>
                </div>
            </fieldset>

            </div>
        
        <div class="app-section">
            <h2>Step 3: Define Strategy</h2>
            
            <div class="form-grid form-grid-cols-2">
                <div class="form-group">
                    <label for="strategy-select">Trading Strategy</label>
                    <select id="strategy-select">
                        <option value="rsi">RSI Strategy (Default)</option>
                        <option value="price-range">Price Range Strategy</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="timeframe-select">Chart Timeframe (for RSI)</label>
                    <select id="timeframe-select">
                        <option value="1">1 Minute</option>
                        <option value="5">5 Minutes</option>
                        <option value="15">15 Minutes</option>
                        <option value="30">30 Minutes</option>
                        <option value="60" selected>1 Hour</option>
                        <option value="240">4 Hours</option>
                        <option value="1440">1 Day</option>
                    </select>
                </div>
            </div>

            <div id="rsi-settings" class="strategy-settings form-grid form-grid-cols-2" style="margin-top: 1rem;">
                <div class="form-group">
                    <label for="rsi-buy">
                        Buy Token A when 14-period RSI is below:
                        <span class="default-text">(Default: 30)</span>
                    </label>
                    <input type="number" id="rsi-buy" value="30">
                </div>
                <div class="form-group">
                    <label for="rsi-sell">
                        Sell Token A when 14-period RSI is above:
                        <span class="default-text">(Default: 70)</span>
                    </label>
                    <input type="number" id="rsi-sell" value="70">
                </div>
            </div>

            <div id="price-range-settings" class="strategy-settings hidden form-grid form-grid-cols-2" style="margin-top: 1rem;">
                <div class="form-group">
                    <label for="price-lower">
                        Lower Buy Price (in Token B)
                    </label>
                    <input type="number" id="price-lower" placeholder="e.g., 0.05">
                </div>
                <div class="form-group">
                    <label for="price-upper">
                        Upper Sell Price (in Token B)
                    </label>
                    <input type="number" id="price-upper" placeholder="e.g., 0.10">
                </div>
            </div>

            <hr>
            <div class="form-grid form-grid-cols-2">
                <div class="form-group">
                    <label for="trade-amount-a">Amount of Token A to SELL:</label>
                    <input type="number" id="trade-amount-a" value="100">
                </div>
                <div class="form-group">
                    <label for="trade-amount-b">Amount of Token B to spend on BUY:</label>
                    <input type="number" id="trade-amount-b" value="10">
                </div>
            </div>

            <div class="form-group" style="margin-top: 1rem;">
                <label for="dex-contract">DEX Router Contract (Alcor is default)</label>
                <input type="text" id="dex-contract" value="alcor.swap">
                <p class="note">
                    Note: The <code>alcor.swap</code> router automatically uses both Liquidity Pools (LPs) and the spot market to find the best trade price.
                </p>
            </div>
        </div>

        <div class="app-section">
            <h2>Step 4: Control Panel</h2>
            <div class="button-grid">
                <button id="start-btn" class="start">
                    Start Bot
                </button>
                <button id="stop-btn" class="stop" disabled>
                    Stop Bot
                </button>
            </div>
            <div class="bot-status-container">
                <span style="color: var(--text-secondary);">Status:</span>
                <strong id="bot-status" class="stopped">STOPPED</strong>
            </div>
        </div>

        <div class="app-section">
            <h2>Bot Log</h2>
            <div id="log-output">
                <p class="log-idle">Bot is idle. Please log in, configure settings, and press Start.</p>
            </div>
        </div>

    </div> <div id="share-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="close-share-modal-btn" class="modal-close-btn">&times;</button>
            <h2>My Trading Bot PnL</h2>
            
            <div class="modal-summary">
                <div class="modal-summary-item">
                    <span class="label">Wallet:</span>
                    <span id="share-wallet" class="value">...</span>
                </div>
                <div class="modal-summary-item">
                    <span class="label">Total Spent (B):</span>
                    <span id="share-spent" class="value">0.00</span>
                </div>
                <div class="modal-summary-item">
                    <span class="label">Total Received (B):</span>
                    <span id="share-received" class="value">0.00</span>
                </div>
                <hr>
                <div class="modal-summary-item modal-summary-total">
                    <span class="label">Net PnL:</span>
                    <span id="share-pnl" class="value neutral">0.00</span>
                </div>
            </div>

            <textarea id="share-text"></textarea> <button id="copy-share-btn">
                Copy Sharable Text
            </button>
        </div>
    </div>


    <script>
        // --- Global Variables ---
        let wax;
        let userAccount = null;
        let botInterval = null;
        let isBotRunning = false;
        let lastPrices = []; // Store prices for PnL estimation (Only used by Sell PnL estimate now)
        let pnlData = { totalSpentTokenB: 0, totalReceivedTokenB: 0, pnl: 0 };
        
        let marketId = null; // Will be fetched from API
        let marketConfig = { baseContract: null, quoteContract: null, isInverted: false }; // Added isInverted flag
        
        let tw = null; // Trendyways library
        
        const WAX_RPC_ENDPOINT = 'https://wax.greymass.com';
        const FEE_RECEIVER = 'qu.ug.wam';
        const FEE_PERCENT = 0.001; // 0.1%
        const ALCOR_API = 'https://wax.alcor.exchange/api/v2';


        // --- DOM Elements ---
        let loginBtn, userAccountDisplay, startBtn, stopBtn, botStatusDisplay, logOutput, pnlDisplay;
        let shareModal, sharePnlBtn, closeShareModalBtn, shareWallet, shareSpent, shareReceived, sharePnl, copyShareBtn, shareText;
        let tokenASymbol, tokenAContract, tokenADecimals, tokenBSymbol, tokenBContract, tokenBDecimals;
        let timeframeSelect, dexContract, tradeAmountA, tradeAmountB;
        let strategySelect, rsiSettings, priceRangeSettings, rsiBuy, rsiSell, priceLower, priceUpper;

        // --- Assign DOM Elements ---
        function assignDomElements() { /* ... content unchanged ... */
            loginBtn = document.getElementById('login-btn'); userAccountDisplay = document.getElementById('user-account'); startBtn = document.getElementById('start-btn'); stopBtn = document.getElementById('stop-btn'); botStatusDisplay = document.getElementById('bot-status'); logOutput = document.getElementById('log-output'); pnlDisplay = document.getElementById('pnl-display'); shareModal = document.getElementById('share-modal'); sharePnlBtn = document.getElementById('share-pnl-btn'); closeShareModalBtn = document.getElementById('close-share-modal-btn'); shareWallet = document.getElementById('share-wallet'); shareSpent = document.getElementById('share-spent'); shareReceived = document.getElementById('share-received'); sharePnl = document.getElementById('share-pnl'); copyShareBtn = document.getElementById('copy-share-btn'); shareText = document.getElementById('share-text'); tokenASymbol = document.getElementById('token-a-symbol'); tokenAContract = document.getElementById('token-a-contract'); tokenADecimals = document.getElementById('token-a-decimals'); tokenBSymbol = document.getElementById('token-b-symbol'); tokenBContract = document.getElementById('token-b-contract'); tokenBDecimals = document.getElementById('token-b-decimals'); timeframeSelect = document.getElementById('timeframe-select'); dexContract = document.getElementById('dex-contract'); tradeAmountA = document.getElementById('trade-amount-a'); tradeAmountB = document.getElementById('trade-amount-b'); strategySelect = document.getElementById('strategy-select'); rsiSettings = document.getElementById('rsi-settings'); priceRangeSettings = document.getElementById('price-range-settings'); rsiBuy = document.getElementById('rsi-buy'); rsiSell = document.getElementById('rsi-sell'); priceLower = document.getElementById('price-lower'); priceUpper = document.getElementById('price-upper');
        }

        // --- PnL Functions ---
        function loadPnlFromStorage() { /* ... content unchanged ... */ 
            const savedData = localStorage.getItem('waxTraderPnl'); if (savedData) { pnlData = JSON.parse(savedData); logMessage("Loaded PnL data from storage.", "system"); } else { logMessage("No PnL data found, starting fresh.", "system"); } updatePnlDisplay(); 
        }
        function savePnlToStorage() { /* ... content unchanged ... */ 
            localStorage.setItem('waxTraderPnl', JSON.stringify(pnlData)); 
        }
        function updatePnl(direction, amountB) { /* ... content unchanged ... */ 
            if (direction === 'buy') { pnlData.totalSpentTokenB += amountB; } else if (direction === 'sell') { pnlData.totalReceivedTokenB += amountB; } pnlData.pnl = pnlData.totalReceivedTokenB - pnlData.totalSpentTokenB; savePnlToStorage(); updatePnlDisplay(); logMessage(`PnL updated: ${pnlData.pnl.toFixed(4)}`, "success"); 
        }
        function updatePnlDisplay() { /* ... content unchanged ... */ 
            const pnlValue = pnlData.pnl || 0; const tokenSymbol = tokenBSymbol.value.trim().toUpperCase() || 'Token B'; pnlDisplay.textContent = `${pnlValue.toFixed(4)} ${tokenSymbol}`; pnlDisplay.className = pnlValue > 0 ? "value positive" : pnlValue < 0 ? "value negative" : "value neutral"; 
        }

        // --- Share Modal Functions ---
        function openShareModal() { /* ... content unchanged ... */ 
            const tokenSymbol = tokenBSymbol.value.trim().toUpperCase() || 'Token B'; const pnlValue = pnlData.pnl || 0; shareWallet.textContent = userAccount || 'N/A'; shareSpent.textContent = `${pnlData.totalSpentTokenB.toFixed(4)} ${tokenSymbol}`; shareReceived.textContent = `${pnlData.totalReceivedTokenB.toFixed(4)} ${tokenSymbol}`; sharePnl.textContent = `${pnlValue.toFixed(4)} ${tokenSymbol}`; sharePnl.className = pnlValue > 0 ? "value positive" : pnlValue < 0 ? "value negative" : "value neutral"; const textToCopy = `📈 My WAX TA Bot Report 📈\n-------------------------\nWallet: ${userAccount}\nNet PnL: ${pnlValue.toFixed(4)} ${tokenSymbol}\n(Spent: ${pnlData.totalSpentTokenB.toFixed(4)} | Received: ${pnlData.totalReceivedTokenB.toFixed(4)})\n-------------------------\nBot by: qu.ug.wam`; shareText.value = textToCopy.trim(); shareModal.classList.add('visible'); 
        }
        function closeShareModal() { /* ... content unchanged ... */ 
            shareModal.classList.remove('visible'); 
        }
        function copyShareText() { /* ... content unchanged ... */ 
            shareText.select(); shareText.setSelectionRange(0, 99999); try { document.execCommand('copy'); copyShareBtn.textContent = 'Copied!'; setTimeout(() => { copyShareBtn.textContent = 'Copy Sharable Text'; }, 2000); } catch (err) { logMessage('Failed to copy share text.', 'error'); } 
        }

        // --- Core Functions ---
        function logMessage(message, level = "info") { /* ... content unchanged ... */ 
            if (!logOutput) { console.log(`[${level.toUpperCase()}] ${message}`); return; } const p = document.createElement('p'); const timestamp = new Date().toLocaleTimeString(); let levelClass = "log-info"; if (level === "error") levelClass = "log-error"; if (level === "success") levelClass = "log-success"; if (level === "warn") levelClass = "log-warn"; if (level === "system") levelClass = "log-system"; p.className = levelClass; p.innerHTML = `<span class="log-time">[${timestamp}]</span> ${message}`; const placeholder = logOutput.querySelector('.log-idle'); if (placeholder) placeholder.remove(); logOutput.prepend(p); 
        }
        function toggleStrategySettings() { /* ... content unchanged ... */ 
            const selectedStrategy = strategySelect.value; rsiSettings.classList.toggle('hidden', selectedStrategy !== 'rsi'); priceRangeSettings.classList.toggle('hidden', selectedStrategy !== 'price-range'); 
        }

        // --- Initialization ---
        window.addEventListener('load', () => { /* ... content unchanged ... */ 
            assignDomElements(); logMessage("Page loaded. Waiting for required libraries...", "system"); waitForLibraries(); 
        });
        function waitForLibraries() { /* ... content unchanged ... */ 
            let interval = setInterval(() => { if (typeof waxjs !== 'undefined' && typeof window.tw !== 'undefined') { clearInterval(interval); logMessage("Libraries loaded successfully.", "success"); initializeApp(); } }, 100); setTimeout(() => { clearInterval(interval); if (typeof waxjs === 'undefined' || typeof window.tw === 'undefined') { let errorMsg = "FATAL: Libraries failed to load after 10 seconds. "; if (typeof waxjs === 'undefined') errorMsg += "waxjs failed. "; if (typeof window.tw === 'undefined') errorMsg += "trendyways (tw) failed. "; logMessage(errorMsg + "Check script tags and file locations.", "error"); } }, 10000); 
        }
        function initializeApp() { /* ... content unchanged ... */ 
            tw = window.tw; wax = new waxjs.WaxJS({ rpcEndpoint: WAX_RPC_ENDPOINT, tryAutoLogin: false }); loadPnlFromStorage(); loginBtn.addEventListener('click', login); startBtn.addEventListener('click', startBot); stopBtn.addEventListener('click', stopBot); sharePnlBtn.addEventListener('click', openShareModal); closeShareModalBtn.addEventListener('click', closeShareModal); copyShareBtn.addEventListener('click', copyShareText); strategySelect.addEventListener('change', toggleStrategySettings); shareModal.addEventListener('click', (e) => { if (e.target === shareModal) closeShareModal(); }); logMessage("App initialized. Please log in.", "system"); logMessage("Market verification disabled. Ensure token contracts are correct before starting.", "warn"); toggleStrategySettings(); 
        }

        // --- Login ---
        async function login() { /* ... content unchanged ... */ 
            try { logMessage("Attempting login...", "system"); userAccount = await wax.login(); userAccountDisplay.textContent = userAccount; loginBtn.disabled = true; loginBtn.textContent = "Logged In"; logMessage(`Logged in as: ${userAccount}`, "success"); } catch (e) { logMessage(`Login failed: ${e.message}`, "error"); } 
        }

        // --- Bot Control ---
        async function startBot() { /* ... content unchanged ... */ 
            if (!userAccount) { logMessage("Please log in before starting the bot.", "error"); return; } if (isBotRunning) return; marketId = null; marketConfig = { baseContract: null, quoteContract: null, isInverted: false }; logMessage("Bot starting... Running first check.", "system"); const successfulFirstRun = await runBotLogic(); if (successfulFirstRun) { isBotRunning = true; botStatusDisplay.textContent = "RUNNING"; botStatusDisplay.className = "running"; startBtn.disabled = true; stopBtn.disabled = false; logMessage("Bot started successfully!", "success"); const checkInterval = parseInt(timeframeSelect.value) * 60 * 1000; botInterval = setInterval(runBotLogic, Math.max(60000, checkInterval)); } else { logMessage("Bot failed to start. Check contracts, symbols, and Alcor API status.", "error"); } 
        }
        function stopBot() { /* ... content unchanged ... */ 
            if (!isBotRunning) return; isBotRunning = false; clearInterval(botInterval); marketId = null; marketConfig = { baseContract: null, quoteContract: null, isInverted: false }; botStatusDisplay.textContent = "STOPPED"; botStatusDisplay.className = "stopped"; startBtn.disabled = false; stopBtn.disabled = true; logMessage("Bot stopped.", "system"); 
        }

        // --- Core Bot Logic ---
        async function runBotLogic() { /* ... uses updated findMarketId, getCurrentPrice ... */ 
             if (!isBotRunning && !userAccount) { return false; } logMessage("Running strategy check...", "info"); try { if (!marketId) { const foundId = await findMarketId(); if (!foundId) { logMessage("Market ID could not be found or validated. Check token contracts.", "error"); return isBotRunning; } marketId = foundId; } const currentPriceData = await getCurrentPrice(); if (!currentPriceData) { logMessage("Could not fetch current price.", "warn"); return isBotRunning; } const currentPrice = currentPriceData.price; logMessage(`Current price: 1 ${tokenASymbol.value.trim().toUpperCase()} = ${currentPrice.toFixed(8)} ${tokenBSymbol.value.trim().toUpperCase()}`, "info"); lastPrices = [{ close: currentPrice }]; const selectedStrategy = strategySelect.value; if (selectedStrategy === 'price-range') { const lowerBuyPrice = parseFloat(priceLower.value); const upperSellPrice = parseFloat(priceUpper.value); if (isNaN(lowerBuyPrice) || isNaN(upperSellPrice) || lowerBuyPrice <= 0 || upperSellPrice <= 0) { logMessage("Price Range: Please set a valid lower and upper price.", "warn"); return true; } if (currentPrice <= lowerBuyPrice) { logMessage(`PRICE BUY TRIGGER! Price (${currentPrice.toFixed(8)}) <= ${lowerBuyPrice}.`, "success"); await executeSwap('buy'); } else if (currentPrice >= upperSellPrice) { logMessage(`PRICE SELL TRIGGER! Price (${currentPrice.toFixed(8)}) >= ${upperSellPrice}.`, "success"); await executeSwap('sell'); } else { logMessage(`Price Range: No trigger. Price is between ${lowerBuyPrice} and ${upperSellPrice}.`, "info"); } } else if (selectedStrategy === 'rsi') { const prices = await getPriceHistory(); if (!prices || prices.length < 14) { logMessage("RSI: Not enough historical data or history fetch failed. Skipping RSI check.", "warn"); } else { const closePrices = prices.map(p => p.close); const rsiValues = tw.rsi(closePrices, 14); const currentRSI = rsiValues[rsiValues.length - 1]; logMessage(`Current RSI: ${currentRSI.toFixed(2)}`, "info"); const buyLevel = parseFloat(rsiBuy.value); const sellLevel = parseFloat(rsiSell.value); if (currentRSI <= buyLevel) { logMessage(`RSI BUY TRIGGER! RSI (${currentRSI.toFixed(2)}) <= ${buyLevel}.`, "success"); await executeSwap('buy'); } else if (currentRSI >= sellLevel) { logMessage(`RSI SELL TRIGGER! RSI (${currentRSI.toFixed(2)}) >= ${sellLevel}.`, "success"); await executeSwap('sell'); } else { logMessage(`RSI: No trigger. RSI is between ${buyLevel} and ${sellLevel}.`, "info"); } } } return true; } catch (e) { logMessage(`Error in bot logic: ${e.message}`, "error"); marketId = null; marketConfig = { baseContract: null, quoteContract: null, isInverted: false }; return false; } 
        }
        
        /**
         * ROBUST: Finds market ID, prioritizing Swap Pools, rejecting ID 0.
         */
        async function findMarketId() {
            // No need to check cache here, startBot resets marketId forcing a fresh check
            
            const tokenA = tokenAContract.value.trim().toLowerCase(); // Use lowercase
            const tokenB = tokenBContract.value.trim().toLowerCase();
            if (!tokenA || !tokenB) {
                 logMessage("Token contracts cannot be empty.", "error");
                 return null;
            }
            logMessage(`Searching for market ${tokenA} / ${tokenB}...`, "system");

            let foundId = null;
            let base = null;
            let quote = null;

            // --- PRIORITY CHANGE: Check SWAP POOLS FIRST ---
            try {
                const url = `${ALCOR_API}/swap/pools`; 
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Swap API failed (${response.status})`);
                
                const swapMarkets = await response.json();
                const foundSwapMarket = swapMarkets.find(m =>
                    (m.tokenA.contract === tokenA && m.tokenB.contract === tokenB) ||
                    (m.tokenA.contract === tokenB && m.tokenB.contract === tokenA)
                );
                
                // CRITICAL: Explicitly check if ID is not 0
                if (foundSwapMarket && foundSwapMarket.id > 0) { 
                    logMessage(`Found SWAP market. ID: ${foundSwapMarket.id}`, "success");
                    foundId = foundSwapMarket.id;
                    // Determine base/quote based on the order they appeared in the found market
                    if (foundSwapMarket.tokenA.contract === tokenA) {
                        base = foundSwapMarket.tokenA.contract; 
                        quote = foundSwapMarket.tokenB.contract;
                    } else {
                        base = foundSwapMarket.tokenB.contract;
                        quote = foundSwapMarket.tokenA.contract;
                    }
                } else if (foundSwapMarket && foundSwapMarket.id === 0) {
                     logMessage(`Found SWAP market but ID is 0. Treating as invalid.`, "warn");
                } else {
                     logMessage("Did not find a valid (>0) SWAP market.", "info");
                }
            } catch (e) {
                logMessage(`Could not check swap markets: ${e.message}`, "warn");
            }

            // --- FALLBACK: Check SPOT markets ONLY if Swap wasn't found ---
            if (!foundId) {
                logMessage("No valid SWAP pool found, checking SPOT markets...", "system");
                try {
                    const url = `${ALCOR_API}/markets`; 
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Spot API failed (${response.status})`);
                    
                    const spotMarkets = await response.json();
                    const foundSpotMarket = spotMarkets.find(m =>
                        (m.base_token.contract === tokenA && m.quote_token.contract === tokenB) ||
                        (m.base_token.contract === tokenB && m.quote_token.contract === tokenA)
                    );
                    
                    if (foundSpotMarket && foundSpotMarket.id > 0) { // Check for valid ID > 0
                        logMessage(`Found SPOT market (using as fallback). ID: ${foundSpotMarket.id}`, "success");
                        foundId = foundSpotMarket.id;
                        base = foundSpotMarket.base_token.contract;
                        quote = foundSpotMarket.quote_token.contract;
                    } else {
                         logMessage("Did not find a valid (>0) SPOT market either.", "info");
                    }
                } catch (e) {
                    logMessage(`Could not check spot markets: ${e.message}`, "warn");
                }
            }
            
            // 3. Validate and Store Result
            if (foundId && base && quote) {
                marketConfig.baseContract = base;
                marketConfig.quoteContract = quote;
                marketConfig.isInverted = (base !== tokenA); // Check if market base is our Token B
                
                logMessage(`Validated Market ID: ${foundId}. Base: ${base}, Quote: ${quote}, Inverted: ${marketConfig.isInverted}`, "system");
                return foundId; // Return the validated ID
            } else {
                logMessage(`No valid market found for ${tokenA} / ${tokenB} on Spot or Swap.`, "error");
                return null; // Explicitly return null if no valid market found
            }
        }

        /**
         * ROBUST: Gets the current price using the /markets/{id} endpoint.
         * Returns { price: number } (price of A in terms of B) or null.
         */
        async function getCurrentPrice() { /* ... content unchanged ... */
            if (!marketId) { logMessage("Cannot get current price without a valid market ID.", "error"); return null; }
            const url = `${ALCOR_API}/markets/${marketId}`;
            logMessage(`Fetching current price for market ${marketId}...`, "system");
            try {
                const response = await fetch(url);
                if (!response.ok) { throw new Error(`Market API failed (${response.status})`); }
                const marketData = await response.json();
                if (!marketData || typeof marketData.last_price === 'undefined') { throw new Error("Market data received is invalid or missing 'last_price'."); }
                let price = parseFloat(marketData.last_price);
                if (marketConfig.isInverted) { 
                    if (price === 0) { logMessage("Warning: Inverted price is 0, cannot calculate reciprocal. Using 0.", "warn"); return { price: 0 }; }
                    logMessage("Market is inverted relative to input. Calculating reciprocal price.", "system");
                    return { price: 1 / price };
                } else {
                    return { price: price };
                }
            } catch (e) { logMessage(`Failed to get current price: ${e.message}`, "error"); return null; }
        }


        /**
         * Gets price history from Alcor API (Used ONLY by RSI strategy now)
         * Returns array of {time, open, high, low, close, volume} or null on failure.
         * Handles inversion based on marketConfig.
         */
        async function getPriceHistory() { /* ... content unchanged ... */
            if (!marketId) { logMessage("Cannot get price history without market ID.", "warn"); return null; }
            const timeframe = timeframeSelect.value; const now = Math.floor(Date.now() / 1000); const from = now - (60 * parseInt(timeframe) * 50); const resolution = timeframe; const url = `${ALCOR_API}/charts/history?market=${marketId}&resolution=${resolution}&from=${from}&to=${now}`;
            logMessage(`Fetching price history for RSI (ID: ${marketId}, TF: ${timeframe}m)...`, "system");
            try {
                const response = await fetch(url);
                if (!response.ok) { if (response.status === 404) { logMessage(`No price history found for market ${marketId} at ${timeframe}m resolution.`, "warn"); return null; } throw new Error(`History API failed (${response.status})`); }
                const data = await response.json(); if (!data || data.length === 0) { logMessage("No price history data returned from Alcor.", "warn"); return null; }
                if (marketConfig.isInverted) {
                     logMessage("History: Market is inverted. Inverting prices.", "system");
                    return data.map(d => ({ time: d.time, open: d.open ? 1 / d.open : 0, high: d.low ? 1 / d.low : 0, low: d.high ? 1 / d.high : 0, close: d.close ? 1 / d.close : 0, volume: d.volume * (d.close || 0) })).filter(d => isFinite(d.open) && isFinite(d.high) && isFinite(d.low) && isFinite(d.close)); 
                } else {
                      return data.map(d => ({ time: d.time, open: parseFloat(d.open || 0), high: parseFloat(d.high || 0), low: parseFloat(d.low || 0), close: parseFloat(d.close || 0), volume: parseFloat(d.volume || 0) })).filter(d => isFinite(d.open) && isFinite(d.high) && isFinite(d.low) && isFinite(d.close));
                }
            } catch (e) { logMessage(`Failed to get price history: ${e.message}`, "error"); return null; }
        }

        /**
         * Executes the swap transaction on Alcor
         */
        async function executeSwap(direction) { /* ... content unchanged ... */ 
            logMessage(`Attempting to execute ${direction.toUpperCase()} swap...`, "system"); try { const config = { aSymbol: tokenASymbol.value.trim().toUpperCase(), aContract: tokenAContract.value.trim(), aDecimals: parseInt(tokenADecimals.value), bSymbol: tokenBSymbol.value.trim().toUpperCase(), bContract: tokenBContract.value.trim(), bDecimals: parseInt(tokenBDecimals.value), dex: dexContract.value.trim(), amountA: parseFloat(tradeAmountA.value), amountB: parseFloat(tradeAmountB.value) }; if (!config.aSymbol || !config.aContract || !config.bSymbol || !config.bContract || isNaN(config.aDecimals) || isNaN(config.bDecimals) || isNaN(config.amountA) || isNaN(config.amountB) || config.amountA <= 0 || config.amountB <= 0) { logMessage("Invalid token configuration or trade amounts.", "error"); return; } let actions = []; if (direction === 'sell') { const totalSellAmount = config.amountA; const feeAmount = totalSellAmount * FEE_PERCENT; const userAmount = totalSellAmount - feeAmount; if (userAmount <= 0) { logMessage("Sell amount too small for fee.", "error"); return; } const userQuantity = `${userAmount.toFixed(config.aDecimals)} ${config.aSymbol}`; const minReturnUser = (0).toFixed(config.bDecimals); const memoUser = `swap,${minReturnUser} ${config.bSymbol},${config.bContract}`; actions.push({ account: config.aContract, name: 'transfer', authorization: [{ actor: userAccount, permission: 'active' }], data: { from: userAccount, to: config.dex, quantity: userQuantity, memo: memoUser } }); const feeQuantity = `${feeAmount.toFixed(config.aDecimals)} ${config.aSymbol}`; if (feeAmount > 0) { actions.push({ account: config.aContract, name: 'transfer', authorization: [{ actor: userAccount, permission: 'active' }], data: { from: userAccount, to: FEE_RECEIVER, quantity: feeQuantity, memo: `0.1% fee from WAX TA Trader` } }); logMessage(`ACTION (Fee): Transfer ${feeQuantity} to ${FEE_RECEIVER}`, "info"); } logMessage(`ACTION (User): Transfer ${userQuantity} to ${config.dex} | Memo: ${memoUser}`, "info"); } else if (direction === 'buy') { const quantity = `${config.amountB.toFixed(config.bDecimals)} ${config.bSymbol}`; const minReturn = (0).toFixed(config.aDecimals); const memo = `swap,${minReturn} ${config.aSymbol},${config.aContract}`; actions.push({ account: config.bContract, name: 'transfer', authorization: [{ actor: userAccount, permission: 'active' }], data: { from: userAccount, to: config.dex, quantity: quantity, memo: memo } }); logMessage(`ACTION: Transfer ${quantity} to ${config.dex} | Memo: ${memo}`, "info"); } const result = await wax.api.transact({ actions }, { blocksBehind: 3, expireSeconds: 1200 }); logMessage(`Swap successful! TxID: ${result.transaction_id.substring(0, 12)}...`, "success"); if (direction === 'buy') { updatePnl('buy', config.amountB); } else if (direction === 'sell') { if (lastPrices.length > 0) { const currentPrice = lastPrices[lastPrices.length - 1].close; const userAmountSold = config.amountA * (1 - FEE_PERCENT); const estimatedReceivedB = userAmountSold * currentPrice; logMessage(`Est. ${estimatedReceivedB.toFixed(config.bDecimals)} ${config.bSymbol} received.`, "info"); updatePnl('sell', estimatedReceivedB); } else { logMessage(`Could not estimate PnL for sell trade, no current price data available.`, "warn"); } } } catch (e) { let errorMessage = e.message; try { const errorJson = JSON.parse(e.message); if (errorJson.error?.details?.length > 0) errorMessage = errorJson.error.details[0].message; else if (errorJson.error?.what) errorMessage = errorJson.error.what; } catch (parseError) {} logMessage(`Swap failed: ${errorMessage}`, "error"); } 
        }
    </script>
</body>
</html>
