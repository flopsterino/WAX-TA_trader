<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WAX TA Trading Bot</title>
    <script src="waxjs.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/7.12.1/polyfill.min.js"></script>
    <script src="trendyways.min.js"></script>

    <style>
        :root{--bg-primary:#1a1c23;--bg-secondary:#242731;--bg-tertiary:#3a3f4c;--border-color:#4a5160;--text-primary:#e0e2e8;--text-secondary:#a0a6b3;--text-cyan:#22d3ee;--text-green:#34d399;--text-red:#f87171;--text-yellow:#facc15;--text-blue:#60a5fa;--accent-cyan:#06b6d4;--accent-cyan-hover:#0891b2;--accent-green:#10b981;--accent-green-hover:#059669;--accent-red:#ef4444;--accent-red-hover:#dc2626;--accent-blue:#3b82f6;--accent-blue-hover:#2563eb;--shadow-color:rgba(0,0,0,0.2);--font-sans:'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;--font-mono:'Courier New', Courier, monospace;}*{box-sizing:border-box;}body{background-color:var(--bg-primary);color:var(--text-primary);font-family:var(--font-sans);margin:0;padding:1rem;min-height:100vh;}@media (min-width: 768px){body{padding:2rem;}}.container{max-width:800px;margin:0 auto;display:flex;flex-direction:column;gap:1.5rem;}h1{font-size:2.25rem;font-weight:700;text-align:center;margin:0 0 1rem 0;color:var(--text-cyan);}h2{font-size:1.5rem;font-weight:600;margin:0 0 1rem 0;border-bottom:1px solid var(--border-color);padding-bottom:0.5rem;color:var(--text-primary);}.app-section{background-color:var(--bg-secondary);padding:1.5rem;border-radius:8px;box-shadow:0 4px 12px var(--shadow-color);}.alert{padding:1rem;border-radius:6px;border-left:4px solid;}.alert-critical{background-color:#450a0a;border-color:var(--text-red);color:#fecaca;}.alert-critical p{margin:0;}.alert-critical strong{color:white;font-weight:600;}fieldset{border:1px solid var(--border-color);border-radius:6px;padding:1rem 1.5rem;margin-bottom:1rem;}legend{padding:0 0.5rem;font-weight:600;color:var(--text-primary);font-size:1.1rem;}.form-grid{display:grid;grid-template-columns:repeat(1, 1fr);gap:1rem;}@media (min-width: 768px){.form-grid-cols-3{grid-template-columns:repeat(3, 1fr);}.form-grid-cols-2{grid-template-columns:repeat(2, 1fr);}}.form-group{display:flex;flex-direction:column;gap:0.25rem;}label{display:block;font-size:0.875rem;font-weight:500;color:var(--text-secondary);}label .default-text{font-size:0.75rem;color:var(--text-cyan);margin-left:0.25rem;}input[type="text"], input[type="number"], select{background-color:var(--bg-tertiary);border:1px solid var(--border-color);color:var(--text-primary);border-radius:6px;padding:0.75rem 1rem;width:100%;transition:border-color 0.2s, box-shadow 0.2s;font-size:0.9rem;}input[type="text"]:focus, input[type="number"]:focus, select:focus{outline:none;border-color:var(--accent-cyan);box-shadow:0 0 0 3px rgba(6, 182, 212, 0.3);}.note{font-size:0.75rem;color:var(--text-secondary);margin-top:0.5rem;}button{font-weight:600;padding:0.75rem 1rem;border-radius:6px;cursor:pointer;border:none;transition:background-color 0.2s, opacity 0.2s;width:100%;font-size:1rem;}button.primary{background-color:var(--accent-cyan);color:var(--bg-primary);}button.primary:hover{background-color:var(--accent-cyan-hover);}button.secondary{background-color:var(--bg-tertiary);color:var(--text-primary);width:auto;font-size:0.8rem;font-weight:500;padding:0.25rem 0.75rem;}button.secondary:hover{background-color:var(--border-color);}button.start{background-color:var(--accent-green);color:white;}button.start:hover{background-color:var(--accent-green-hover);}button.stop{background-color:var(--accent-red);color:white;}button.stop:hover{background-color:var(--accent-red-hover);}button:disabled{background-color:var(--bg-tertiary);color:var(--text-secondary);cursor:not-allowed;opacity:0.7;}.button-grid{display:grid;grid-template-columns:1fr 1fr;gap:1rem;margin-bottom:1rem;}.status-grid{margin-top:1rem;display:flex;flex-direction:column;gap:0.75rem;}.status-item{display:flex;justify-content:space-between;align-items:center;}.status-item .label{color:var(--text-secondary);font-size:0.9rem;}.status-item .value{font-weight:700;font-size:1rem;}.status-item .value-group{display:flex;align-items:center;gap:0.5rem;}#user-account{color:var(--text-green);}#pnl-display.positive{color:var(--text-green);}#pnl-display.negative{color:var(--text-red);}#pnl-display.neutral{color:var(--text-secondary);}.bot-status-container{text-align:center;}#bot-status{font-weight:700;font-size:1.1rem;}#bot-status.running{color:var(--text-green);}#bot-status.stopped{color:var(--text-red);}#log-output{font-family:var(--font-mono);max-height:400px;overflow-y:auto;background-color:var(--bg-primary);border:1px solid var(--border-color);padding:1rem;border-radius:6px;font-size:0.875rem;}#log-output p{margin:0 0 0.35rem 0;border-bottom:1px solid var(--bg-tertiary);padding-bottom:0.35rem;word-break:break-all;line-height:1.6;}#log-output p:last-child{border-bottom:none;margin-bottom:0;}#log-output .log-time{color:var(--text-secondary);margin-right:0.5rem;}#log-output .log-info{color:var(--text-primary);}#log-output .log-error{color:var(--text-red);}#log-output .log-success{color:var(--text-green);}#log-output .log-warn{color:var(--text-yellow);}#log-output .log-system{color:var(--text-cyan);}#log-output .log-idle{color:var(--text-secondary);}.strategy-settings.hidden{display:none;}hr{border:none;border-top:1px solid var(--border-color);margin:1.5rem 0;}.modal-overlay{display:none;position:fixed;inset:0;background-color:rgba(0,0,0,0.75);align-items:center;justify-content:center;z-index:50;padding:1rem;}.modal-overlay.visible{display:flex;}.modal-content{background-color:var(--bg-secondary);width:100%;max-width:500px;padding:2rem;border-radius:8px;box-shadow:0 10px 30px var(--shadow-color);position:relative;}.modal-close-btn{position:absolute;top:0.75rem;right:1.25rem;color:var(--text-secondary);font-size:2.5rem;font-weight:300;background:none;border:none;cursor:pointer;padding:0;width:auto;line-height:1;}.modal-close-btn:hover{color:var(--text-primary);}.modal-content h2{text-align:center;color:var(--text-cyan);margin-top:0;margin-bottom:1.5rem;border:none;}.modal-summary{background-color:var(--bg-tertiary);padding:1.5rem;border-radius:6px;margin-bottom:1.5rem;display:flex;flex-direction:column;gap:0.75rem;}.modal-summary-item{display:flex;justify-content:space-between;align-items:center;}.modal-summary-item .label{color:var(--text-secondary);}.modal-summary-item .value{font-weight:600;}#share-wallet{color:var(--text-cyan);}#share-spent{color:var(--text-red);}#share-received{color:var(--text-green);}.modal-summary hr{margin:0.5rem 0;}.modal-summary-total{font-size:1.25rem;font-weight:700;}#share-pnl.positive{color:var(--text-green);}#share-pnl.negative{color:var(--text-red);}#share-pnl.neutral{color:var(--text-secondary);}#copy-share-btn{background-color:var(--accent-cyan);color:var(--bg-primary);}#copy-share-btn:hover{background-color:var(--accent-cyan-hover);}#share-text{position:absolute;left:-9999px;opacity:0;}
    </style>
</head>
<body>
    <div class="container">
        <h1>WAX TA Trading Bot</h1>
        
        <div class="alert alert-critical" role="alert">
            <p><strong>High Risk: Use at Your Own Risk</strong></p>
            <p>This is an educational tool. Automated trading is extremely risky and can lead to a total loss of funds. You are solely responsible for your actions. A 0.1% fee on all sell trades is sent to `qu.ug.wam`.</p>
        </div>

        <div class="app-section">
            <h2>Step 1: Connect & Status</h2>
            <button id="login-btn" class="primary"> Login with WAX Wallet </button>
            <div class="status-grid">
                <div class="status-item">
                    <span class="label">Wallet:</span> 
                    <strong id="user-account" class="value">Not Logged In</strong>
                </div>
                <div class="status-item">
                    <span class="label">Your PnL:</span>
                    <div class="value-group">
                        <span id="pnl-display" class="value neutral">0.00</span>
                        <button id="share-pnl-btn" class="secondary">Share</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="app-section">
            <h2>Step 2: Configure Tokens</h2>
            <div class="form-grid form-grid-cols-2">
                <div class="form-group">
                    <label for="select-token-a">Token A (The token you want to trade)</label>
                    <select id="select-token-a">
                        </select>
                </div>
                <div class="form-group">
                    <label for="select-token-b">Token B (The token you spend/receive, e.g., WAX)</label>
                    <select id="select-token-b">
                        </select>
                </div>
            </div>
            <button id="add-token-btn" class="primary" style="margin-top: 1rem;">Add New Token</button>
        </div>
        <div class="app-section">
            <h2>Step 3: Define Strategy</h2>
            <div class="form-grid form-grid-cols-2">
                <div class="form-group">
                    <label for="strategy-select">Trading Strategy</label>
                    <select id="strategy-select">
                        <option value="rsi">RSI Strategy (Default)</option>
                        <option value="price-range">Price Range Strategy</option>
                        <option value="short-term">Short Term Trading (1-min)</option> 
                    </select>
                </div>
                <div class="form-group">
                    <label for="timeframe-select">Chart Timeframe</label>
                    <select id="timeframe-select">
                        <option value="1">1 Minute (Required for Short Term)</option>
                        <option value="5">5 Minutes</option>
                        <option value="15">15 Minutes</option>
                        <option value="30">30 Minutes</option>
                        <option value="60" selected>1 Hour</option>
                        <option value="240">4 Hours</option>
                        <option value="1440">1 Day</option>
                    </select>
                </div>
            </div>

            <div id="rsi-settings" class="strategy-settings form-grid form-grid-cols-2" style="margin-top: 1rem;">
                <div class="form-group">
                    <label for="rsi-buy"> Buy Token A when 14-period RSI is below: <span class="default-text">(Default: 30)</span> </label>
                    <input type="number" id="rsi-buy" value="30">
                </div>
                <div class="form-group">
                    <label for="rsi-sell"> Sell Token A when 14-period RSI is above: <span class="default-text">(Default: 70)</span> </label>
                    <input type="number" id="rsi-sell" value="70">
                </div>
            </div>
            
            <div id="price-range-settings" class="strategy-settings hidden form-grid form-grid-cols-2" style="margin-top: 1rem;">
                <div class="form-group">
                    <label for="price-lower"> Lower Buy Price (in Token B) </label>
                    <input type="number" id="price-lower" placeholder="e.g., 0.05">
                </div>
                <div class="form-group">
                    <label for="price-upper"> Upper Sell Price (in Token B) </label>
                    <input type="number" id="price-upper" placeholder="e.g., 0.10">
                </div>
            </div>

            <div id="short-term-settings" class="strategy-settings hidden" style="margin-top: 1rem;">
                <fieldset>
                    <legend>Short Term Strategy (1-Minute)</legend>
                    <div class="form-grid form-grid-cols-2">
                        <div class="form-group">
                             <label for="short-term-strategy-select">Select 1-min Strategy</label>
                             <select id="short-term-strategy-select">
                                <option value="volume-spike">Volume Spike (Majority Rules)</option>
                                <option value="ema-crossover">EMA Crossover</option>
                             </select>
                        </div>
                         <div class="form-group">
                            <label for="short-term-tf-warning" style="color: var(--text-yellow);">Timeframe Warning</label>
                            <input type="text" id="short-term-tf-warning" value="Set Timeframe to 1-Min" disabled style="color: var(--text-yellow); border-color: var(--text-yellow);">
                        </div>
                    </div>
                </fieldset>

                <div id="volume-spike-settings" class="strategy-settings hidden">
                    <fieldset style="margin-top: 1rem; border-color: var(--accent-cyan);">
                        <legend style="color: var(--accent-cyan);">Volume Spike (Majority Rules) Settings</legend>
                        <p class="note" style="margin-top:0; margin-bottom: 1rem;">Buys if 2-of-3 signals are true (Trend, Volume, Price Action). Sells on Take Profit / Stop Loss.</p>
                        <div class="form-grid form-grid-cols-3">
                             <div class="form-group">
                                <label for="vol-multiplier">Volume Multiplier <span class="default-text">(e.g., 5)</span></label>
                                <input type="number" id="vol-multiplier" value="5">
                            </div>
                            <div class="form-group">
                                <label for="vol-avg-candles">Avg. Volume Candles <span class="default-text">(e.g., 20)</span></label>
                                <input type="number" id="vol-avg-candles" value="20">
                            </div>
                             <div class="form-group">
                                <label for="vol-trend-ema">Trend EMA Period <span class="default-text">(0=off)</span></label>
                                <input type="number" id="vol-trend-ema" value="50">
                            </div>
                        </div>
                        <div class="form-grid form-grid-cols-2" style="margin-top: 1rem;">
                            <div class="form-group">
                                <label for="vol-take-profit">Take Profit % <span class="default-text">(e.g., 3)</span></label>
                                <input type="number" id="vol-take-profit" value="3">
                            </div>
                            <div class="form-group">
                                <label for="vol-stop-loss">Stop Loss % <span class="default-text">(e.g., 2)</span></label>
                                <input type="number" id="vol-stop-loss" value="2">
                            </div>
                        </div>
                    </fieldset>
                </div>

                <div id="ema-crossover-settings" class="strategy-settings hidden">
                     <fieldset style="margin-top: 1rem; border-color: var(--accent-green);">
                        <legend style="color: var(--accent-green);">EMA Crossover Settings</legend>
                        <p class="note" style="margin-top:0; margin-bottom: 1rem;">Buys when the Fast EMA crosses *above* the Slow EMA. Sells when it crosses *below*.</p>
                        <div class="form-grid form-grid-cols-2">
                             <div class="form-group">
                                <label for="ema-fast">Fast EMA Period <span class="default-text">(e.g., 9)</span></label>
                                <input type="number" id="ema-fast" value="9">
                            </div>
                            <div class="form-group">
                                <label for="ema-slow">Slow EMA Period <span class="default-text">(e.g., 21)</span></label>
                                <input type="number" id="ema-slow" value="21">
                            </div>
                        </div>
                    </fieldset>
                </div>

            </div>
            <hr>
            <div class="form-grid form-grid-cols-2">
                <div class="form-group">
                    <label for="trade-amount-a">Amount of Token A to SELL:</label>
                    <input type="number" id="trade-amount-a" value="100">
                </div>
                <div class="form-group">
                    <label for="trade-amount-b">Amount of Token B to spend on BUY:</label>
                    <input type="number" id="trade-amount-b" value="10">
                </div>
            </div>
            <div class="form-group" style="margin-top: 1rem;">
                <label for="dex-contract">DEX Router Contract (Alcor is default)</label>
                <input type="text" id="dex-contract" value="alcor.swap">
                <p class="note"> Note: The <code>alcor.swap</code> router automatically uses both Liquidity Pools (LPs) and the spot market to find the best trade price. </p>
            </div>
        </div>

        <div class="app-section">
            <h2>Step 4: Control Panel</h2>
            <div class="button-grid">
                <button id="start-btn" class="start"> Start Bot </button>
                <button id="stop-btn" class="stop" disabled> Stop Bot </button>
            </div>
            <div class="bot-status-container">
                <span style="color: var(--text-secondary);">Status:</span> 
                <strong id="bot-status" class="stopped">STOPPED</strong>
            </div>
        </div>

        <div class="app-section">
            <h2>Bot Log</h2>
            <div id="log-output">
                <p class="log-idle">Bot is idle. Please log in, configure settings, and press Start.</p>
            </div>
        </div>
    </div> 

    <div id="share-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="close-share-modal-btn" class="modal-close-btn">&times;</button>
            <h2>My Trading Bot PnL</h2>
            <div class="modal-summary">
                <div class="modal-summary-item"><span class="label">Wallet:</span><span id="share-wallet" class="value">...</span></div>
                <div class="modal-summary-item"><span class="label">Total Spent (B):</span><span id="share-spent" class="value">0.00</span></div>
                <div class="modal-summary-item"><span class="label">Total Received (B):</span><span id="share-received" class="value">0.00</span></div>
                <hr>
                <div class="modal-summary-item modal-summary-total"><span class="label">Net PnL:</span><span id="share-pnl" class="value neutral">0.00</span></div>
            </div>
            <textarea id="share-text"></textarea> 
            <button id="copy-share-btn"> Copy Sharable Text </button>
        </div>
    </div>

    <div id="add-token-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="close-add-token-modal-btn" class="modal-close-btn">&times;</button>
            <h2>Add New Token</h2>
            <div class="form-grid" style="gap: 1.5rem;">
                 <div class="form-group">
                    <label for="modal-token-symbol">Symbol (e.g., TLM)</label>
                    <input type="text" id="modal-token-symbol" placeholder="TLM">
                </div>
                <div class="form-group">
                    <label for="modal-token-contract">Contract (e.g., alien.worlds)</label>
                    <input type="text" id="modal-token-contract" placeholder="alien.worlds">
                </div>
                <div class="form-group">
                    <label for="modal-token-decimals">Decimals (e.g., 4)</label>
                    <input type="number" id="modal-token-decimals" placeholder="4">
                </div>
            </div>
            <button id="save-token-btn" class="primary" style="margin-top: 1.5rem;">Save Token</button>
        </div>
    </div>
    <script>
        // --- Global Variables ---
        let wax;
        let userAccount = null;
        let botInterval = null;
        let isBotRunning = false;
        let lastPrices = []; 
        let pnlData = { totalSpentTokenB: 0, totalReceivedTokenB: 0, pnl: 0 };
        let botState = { inPosition: false, buyPrice: 0.0, strategy: null };
        let currentMarket = { id: null, type: null }; 
        let marketConfig = { baseContract: null, quoteContract: null, isInverted: false };
        let tw = null; 
        
        let tokenList = [];
        const DEFAULT_TOKENS = [
            { symbol: "WAX", contract: "eosio.token", decimals: 8 },
            { symbol: "TLM", contract: "alien.worlds", decimals: 4 },
            { symbol: "AETHER", contract: "aether.rplanet", decimals: 4 }
        ];

        const WAX_RPC_ENDPOINT = 'https://wax.greymass.com';
        const FEE_RECEIVER = 'qu.ug.wam';
        const FEE_PERCENT = 0.001; 
        const ALCOR_API = 'https://wax.alcor.exchange/api/v2';

        // --- DOM Elements ---
        let loginBtn, userAccountDisplay, startBtn, stopBtn, botStatusDisplay, logOutput, pnlDisplay;
        let shareModal, sharePnlBtn, closeShareModalBtn, shareWallet, shareSpent, shareReceived, sharePnl, copyShareBtn, shareText;
        
        let selectTokenA, selectTokenB, addTokenBtn;
        let addTokenModal, closeAddTokenModalBtn, saveTokenBtn, modalTokenSymbol, modalTokenContract, modalTokenDecimals;
        
        let timeframeSelect, dexContract, tradeAmountA, tradeAmountB;
        let strategySelect, rsiSettings, priceRangeSettings, rsiBuy, rsiSell, priceLower, priceUpper;
        
        // [ --- MODIFIED: DOM Elements for Bundled Strategy --- ]
        let shortTermSettings, shortTermStrategySelect, shortTermTfWarning;
        let volumeSpikeSettings, volMultiplier, volAvgCandles, volTakeProfit, volStopLoss, volTrendEma;
        let emaCrossoverSettings, emaFast, emaSlow;


        // --- Assign DOM Elements ---
        function assignDomElements() {
            loginBtn = document.getElementById('login-btn'); 
            userAccountDisplay = document.getElementById('user-account'); 
            startBtn = document.getElementById('start-btn'); 
            stopBtn = document.getElementById('stop-btn'); 
            botStatusDisplay = document.getElementById('bot-status'); 
            logOutput = document.getElementById('log-output'); 
            pnlDisplay = document.getElementById('pnl-display'); 
            shareModal = document.getElementById('share-modal'); 
            sharePnlBtn = document.getElementById('share-pnl-btn'); 
            closeShareModalBtn = document.getElementById('close-share-modal-btn'); 
            shareWallet = document.getElementById('share-wallet'); 
            shareSpent = document.getElementById('share-spent'); 
            shareReceived = document.getElementById('share-received'); 
            sharePnl = document.getElementById('share-pnl'); 
            copyShareBtn = document.getElementById('copy-share-btn'); 
            shareText = document.getElementById('share-text'); 
            
            selectTokenA = document.getElementById('select-token-a');
            selectTokenB = document.getElementById('select-token-b');
            addTokenBtn = document.getElementById('add-token-btn');
            addTokenModal = document.getElementById('add-token-modal');
            closeAddTokenModalBtn = document.getElementById('close-add-token-modal-btn');
            saveTokenBtn = document.getElementById('save-token-btn');
            modalTokenSymbol = document.getElementById('modal-token-symbol');
            modalTokenContract = document.getElementById('modal-token-contract');
            modalTokenDecimals = document.getElementById('modal-token-decimals');

            timeframeSelect = document.getElementById('timeframe-select'); 
            dexContract = document.getElementById('dex-contract'); 
            tradeAmountA = document.getElementById('trade-amount-a'); 
            tradeAmountB = document.getElementById('trade-amount-b'); 
            strategySelect = document.getElementById('strategy-select'); 
            rsiSettings = document.getElementById('rsi-settings'); 
            priceRangeSettings = document.getElementById('price-range-settings'); 
            rsiBuy = document.getElementById('rsi-buy'); 
            rsiSell = document.getElementById('rsi-sell'); 
            priceLower = document.getElementById('price-lower'); 
            priceUpper = document.getElementById('price-upper');

            // [ --- MODIFIED: Assign Bundled Strategy DOM Elements --- ]
            shortTermSettings = document.getElementById('short-term-settings');
            shortTermStrategySelect = document.getElementById('short-term-strategy-select');
            shortTermTfWarning = document.getElementById('short-term-tf-warning');
            
            volumeSpikeSettings = document.getElementById('volume-spike-settings');
            volMultiplier = document.getElementById('vol-multiplier');
            volAvgCandles = document.getElementById('vol-avg-candles');
            volTakeProfit = document.getElementById('vol-take-profit');
            volStopLoss = document.getElementById('vol-stop-loss');
            volTrendEma = document.getElementById('vol-trend-ema'); // New field

            emaCrossoverSettings = document.getElementById('ema-crossover-settings');
            emaFast = document.getElementById('ema-fast');
            emaSlow = document.getElementById('ema-slow');
        }

        // --- PnL Functions ---
        function loadPnlFromStorage() { const savedData = localStorage.getItem('waxTraderPnl'); if (savedData) { pnlData = JSON.parse(savedData); logMessage("Loaded PnL data from storage.", "system"); } else { logMessage("No PnL data found, starting fresh.", "system"); } updatePnlDisplay(); }
        function savePnlToStorage() { localStorage.setItem('waxTraderPnl', JSON.stringify(pnlData)); }
        function updatePnl(direction, amountB) { if (direction === 'buy') { pnlData.totalSpentTokenB += amountB; } else if (direction === 'sell') { pnlData.totalReceivedTokenB += amountB; } pnlData.pnl = pnlData.totalReceivedTokenB - pnlData.totalSpentTokenB; savePnlToStorage(); updatePnlDisplay(); logMessage(`PnL updated: ${pnlData.pnl.toFixed(4)}`, "success"); }
        
        function updatePnlDisplay() {
            const pnlValue = pnlData.pnl || 0;
            const tokenB = getSelectedTokenConfig('select-token-b');
            const tokenSymbol = tokenB ? tokenB.symbol.toUpperCase() : 'Token B'; 
            
            pnlDisplay.textContent = `${pnlValue.toFixed(4)} ${tokenSymbol}`;
            pnlDisplay.className = pnlValue > 0 ? "value positive" : pnlValue < 0 ? "value negative" : "value neutral";
        }

        // --- Share Modal Functions ---
        function openShareModal() {
            const tokenB = getSelectedTokenConfig('select-token-b');
            const tokenSymbol = tokenB ? tokenB.symbol.toUpperCase() : 'Token B';
            const pnlValue = pnlData.pnl || 0; 
            
            shareWallet.textContent = userAccount || 'N/A'; 
            shareSpent.textContent = `${pnlData.totalSpentTokenB.toFixed(4)} ${tokenSymbol}`; 
            shareReceived.textContent = `${pnlData.totalReceivedTokenB.toFixed(4)} ${tokenSymbol}`; 
            sharePnl.textContent = `${pnlValue.toFixed(4)} ${tokenSymbol}`; 
            sharePnl.className = pnlValue > 0 ? "value positive" : pnlValue < 0 ? "value negative" : "value neutral"; 
            
            const textToCopy = `📈 My WAX TA Bot Report 📈\n-------------------------\nWallet: ${userAccount}\nNet PnL: ${pnlValue.toFixed(4)} ${tokenSymbol}\n(Spent: ${pnlData.totalSpentTokenB.toFixed(4)} | Received: ${pnlData.totalReceivedTokenB.toFixed(4)})\n-------------------------\nBot by: qu.ug.wam`; 
            shareText.value = textToCopy.trim(); 
            shareModal.classList.add('visible'); 
        }
        function closeShareModal() { shareModal.classList.remove('visible'); }
        function copyShareText() { shareText.select(); shareText.setSelectionRange(0, 99999); try { document.execCommand('copy'); copyShareBtn.textContent = 'Copied!'; setTimeout(() => { copyShareBtn.textContent = 'Copy Sharable Text'; }, 2000); } catch (err) { logMessage('Failed to copy share text.', 'error'); } }


        // --- Bot State Management (with strategy) ---
        function loadBotState() {
            const savedData = localStorage.getItem('waxTraderBotState');
            if (savedData) {
                botState = JSON.parse(savedData);
                if(botState.inPosition) {
                    logMessage(`Loaded bot state: IN POSITION (via ${botState.strategy}). Bought at ${botState.buyPrice}. Looking for sell...`, "warn");
                } else {
                    logMessage("Loaded bot state: Not in position.", "system");
                }
            } else {
                 // Ensure default state has all keys
                botState = { inPosition: false, buyPrice: 0.0, strategy: null };
                logMessage("No bot state found, starting fresh.", "system");
            }
        }
        function saveBotState() {
            localStorage.setItem('waxTraderBotState', JSON.stringify(botState));
        }

        // --- Core Functions ---
        function logMessage(message, level = "info") { if (!logOutput) { console.log(`[${level.toUpperCase()}] ${message}`); return; } const p = document.createElement('p'); const timestamp = new Date().toLocaleTimeString(); let levelClass = "log-info"; if (level === "error") levelClass = "log-error"; if (level === "success") levelClass = "log-success"; if (level === "warn") levelClass = "log-warn"; if (level === "system") levelClass = "log-system"; p.className = levelClass; p.innerHTML = `<span class="log-time">[${timestamp}]</span> ${message}`; const placeholder = logOutput.querySelector('.log-idle'); if (placeholder) placeholder.remove(); logOutput.prepend(p); }
        
        // [ --- MODIFIED: `toggleStrategySettings` for bundled strategies --- ]
        function toggleStrategySettings() { 
            const selectedStrategy = strategySelect.value; 
            
            // Toggle main panels
            rsiSettings.classList.toggle('hidden', selectedStrategy !== 'rsi'); 
            priceRangeSettings.classList.toggle('hidden', selectedStrategy !== 'price-range'); 
            shortTermSettings.classList.toggle('hidden', selectedStrategy !== 'short-term');
            
            // Toggle sub-panels if short-term is selected
            if(selectedStrategy === 'short-term') {
                const subStrategy = shortTermStrategySelect.value;
                volumeSpikeSettings.classList.toggle('hidden', subStrategy !== 'volume-spike');
                emaCrossoverSettings.classList.toggle('hidden', subStrategy !== 'ema-crossover');
                
                // Show warning if 1-min timeframe isn't selected
                if(timeframeSelect.value !== '1') {
                    shortTermTfWarning.style.display = 'block';
                } else {
                    shortTermTfWarning.style.display = 'none';
                }
            }
        }

        // --- Initialization ---
        window.addEventListener('load', () => { assignDomElements(); logMessage("Page loaded. Waiting for required libraries...", "system"); waitForLibraries(); });
        function waitForLibraries() { let interval = setInterval(() => { if (typeof waxjs !== 'undefined' && typeof window.tw !== 'undefined') { clearInterval(interval); logMessage("Libraries loaded successfully.", "success"); initializeApp(); } }, 100); setTimeout(() => { clearInterval(interval); if (typeof waxjs === 'undefined' || typeof window.tw === 'undefined') { let errorMsg = "FATAL: Libraries failed to load after 10 seconds. "; if (typeof waxjs === 'undefined') errorMsg += "waxjs failed. "; if (typeof window.tw === 'undefined') errorMsg += "trendyways (tw) failed. "; logMessage(errorMsg + "Check script tags and file locations.", "error"); } }, 10000); }
        
        function initializeApp() {
            tw = window.tw; 
            wax = new waxjs.WaxJS({ rpcEndpoint: WAX_RPC_ENDPOINT, tryAutoLogin: false }); 
            
            loadPnlFromStorage();
            loadTokenList();
            loadBotState(); 
            
            loginBtn.addEventListener('click', login); 
            startBtn.addEventListener('click', startBot); 
            stopBtn.addEventListener('click', stopBot); 
            sharePnlBtn.addEventListener('click', openShareModal); 
            closeShareModalBtn.addEventListener('click', closeShareModal); 
            copyShareBtn.addEventListener('click', copyShareText); 
            strategySelect.addEventListener('change', toggleStrategySettings); 
            timeframeSelect.addEventListener('change', toggleStrategySettings);
            shareModal.addEventListener('click', (e) => { if (e.target === shareModal) closeShareModal(); }); 

            addTokenBtn.addEventListener('click', openAddTokenModal);
            closeAddTokenModalBtn.addEventListener('click', closeAddTokenModal);
            saveTokenBtn.addEventListener('click', saveNewToken); 
            addTokenModal.addEventListener('click', (e) => { if (e.target === addTokenModal) closeAddTokenModal(); });

            selectTokenA.addEventListener('change', updatePnlDisplay);
            selectTokenB.addEventListener('change', updatePnlDisplay);

            shortTermStrategySelect.addEventListener('change', toggleStrategySettings);

            logMessage("App initialized. Please log in.", "system");
            toggleStrategySettings(); 
        }

        // --- Login ---
        async function login() { try { logMessage("Attempting login...", "system"); userAccount = await wax.login(); userAccountDisplay.textContent = userAccount; loginBtn.disabled = true; loginBtn.textContent = "Logged In"; logMessage(`Logged in as: ${userAccount}`, "success"); } catch (e) { logMessage(`Login failed: ${e.message}`, "error"); } }


        // --- Token Management Functions ---
        function loadTokenList() {
            const savedTokens = localStorage.getItem('waxTraderTokens');
            if (savedTokens) {
                try {
                    tokenList = JSON.parse(savedTokens);
                    if (!Array.isArray(tokenList)) { 
                         tokenList = [...DEFAULT_TOKENS];
                         logMessage("Token list in storage was corrupted. Loading defaults.", "warn");
                         saveTokenList();
                    } else {
                        logMessage("Loaded token list from storage.", "system");
                    }
                } catch(e) {
                     tokenList = [...DEFAULT_TOKENS];
                     logMessage("Failed to parse token list. Loading defaults.", "warn");
                     saveTokenList();
                }
            } else {
                tokenList = [...DEFAULT_TOKENS];
                logMessage("No token list found, loading defaults.", "system");
                saveTokenList();
            }
            populateTokenDropdowns();
        }
        function saveTokenList() { localStorage.setItem('waxTraderTokens', JSON.stringify(tokenList)); }
        function populateTokenDropdowns() {
            const currentA = selectTokenA.value;
            const currentB = selectTokenB.value;
            selectTokenA.innerHTML = '';
            selectTokenB.innerHTML = '';
            if (tokenList.length === 0) { const option = "<option value='-1'>Please add a token...</option>"; selectTokenA.innerHTML = option; selectTokenB.innerHTML = option; return; }
            tokenList.forEach((token, index) => { if (token && token.symbol && token.contract) { const optionHTML = `<option value="${index}">${token.symbol.toUpperCase()} (${token.contract})</option>`; selectTokenA.insertAdjacentHTML('beforeend', optionHTML); selectTokenB.insertAdjacentHTML('beforeend', optionHTML); } });
            selectTokenA.value = (currentA && tokenList[currentA]) ? currentA : "1"; 
            selectTokenB.value = (currentB && tokenList[currentB])? currentB : "0"; 
             if (tokenList.length > 1) { if (selectTokenA.value === "") selectTokenA.value = "1"; if (selectTokenB.value === "") selectTokenB.value = "0"; } else if (tokenList.length === 1) { if (selectTokenA.value === "") selectTokenA.value = "0"; if (selectTokenB.value === "") selectTokenB.value = "0"; }
            updatePnlDisplay(); 
        }
        function openAddTokenModal() { modalTokenSymbol.value = ''; modalTokenContract.value = ''; modalTokenDecimals.value = ''; addTokenModal.classList.add('visible'); }
        function closeAddTokenModal() { addTokenModal.classList.remove('visible'); }
        
        async function saveNewToken() {
            const symbol = modalTokenSymbol.value.trim().toUpperCase();
            const contract = modalTokenContract.value.trim().toLowerCase();
            let decimals = parseInt(modalTokenDecimals.value); 
            if (!symbol || !contract || isNaN(decimals) || decimals < 0) { logMessage("Invalid token details. Please fill all fields correctly.", "error"); return; }
            const isDuplicate = tokenList.some(token => token.symbol === symbol && token.contract === contract);
            if (isDuplicate) { logMessage(`Token ${symbol}@${contract} is already in your list.`, "warn"); return; }

            const tokenId = `${symbol.toLowerCase()}-${contract}`;
            const verificationUrl = `${ALCOR_API}/tokens/${tokenId}`;
            logMessage(`Verifying token ${symbol}@${contract} with Alcor API...`, "system");
            saveTokenBtn.disabled = true; 
            saveTokenBtn.textContent = 'Verifying...';
            try {
                const response = await fetch(verificationUrl);
                if (response.ok) {
                    const tokenData = await response.json();
                    const verifiedSymbol = tokenData.symbol;
                    const verifiedContract = tokenData.contract;
                    const verifiedDecimals = parseInt(tokenData.decimals);
                    logMessage(`Verification successful: ${verifiedSymbol}@${verifiedContract}.`, "success");
                     const isVerifiedDuplicate = tokenList.some(token => token.symbol === verifiedSymbol && token.contract === verifiedContract);
                    if (isVerifiedDuplicate) { logMessage(`Token ${verifiedSymbol}@${verifiedContract} is already in your list.`, "warn"); closeAddTokenModal(); return; }
                    tokenList.push({ symbol: verifiedSymbol, contract: verifiedContract, decimals: isNaN(verifiedDecimals) ? decimals : verifiedDecimals });
                    saveTokenList();
                    populateTokenDropdowns();
                    logMessage(`Added new token: ${verifiedSymbol}@${verifiedContract}`, "success");
                    closeAddTokenModal();
                } else if (response.status === 404) {
                    logMessage(`Verification failed: Token ${symbol}@${contract} not found on Alcor.`, "error");
                } else {
                    logMessage(`Verification failed: API returned status ${response.status} for ${symbol}@${contract}.`, "error");
                }
            } catch (e) {
                logMessage(`Error during token verification: ${e.message}`, "error");
            } finally {
                saveTokenBtn.disabled = false;
                saveTokenBtn.textContent = 'Save Token';
            }
        }
        function getSelectedTokenConfig(elementId) { const selectEl = document.getElementById(elementId); if (!selectEl) return null; const selectedIndex = parseInt(selectEl.value); if (isNaN(selectedIndex) || selectedIndex < 0 || !tokenList[selectedIndex]) { return null; } return tokenList[selectedIndex]; }
        

        // --- Bot Control ---
        async function startBot() { 
            if (!userAccount) { logMessage("Please log in before starting the bot.", "error"); return; } 
            if (isBotRunning) return; 
            currentMarket = { id: null, type: null }; 
            marketConfig = { baseContract: null, quoteContract: null, isInverted: false }; 

            const selectedStrategy = strategySelect.value;
            if (selectedStrategy === 'short-term' && timeframeSelect.value !== '1') {
                logMessage("Short Term Strategies require the '1 Minute' timeframe to be selected. Bot not started.", "error");
                return;
            }

            logMessage("Bot starting... Running first check.", "system"); 
            const successfulFirstRun = await runBotLogic(); 
            if (successfulFirstRun) { 
                isBotRunning = true; 
                botStatusDisplay.textContent = "RUNNING"; 
                botStatusDisplay.className = "running"; 
                startBtn.disabled = true; 
                stopBtn.disabled = false; 
                logMessage("Bot started successfully!", "success"); 
                const checkInterval = parseInt(timeframeSelect.value) * 60 * 1000; 
                botInterval = setInterval(runBotLogic, Math.max(60000, checkInterval)); // Run at least every 60s
            } else { 
                logMessage("Bot failed to start. Check contracts, symbols, and Alcor API status.", "error"); 
            } 
        }
        function stopBot() { 
            if (!isBotRunning) return; 
            isBotRunning = false; 
            clearInterval(botInterval); 
            currentMarket = { id: null, type: null }; 
            marketConfig = { baseContract: null, quoteContract: null, isInverted: false }; 
            botState = { inPosition: false, buyPrice: 0.0, strategy: null };
            saveBotState();
            logMessage("Bot state reset.", "system");
            
            botStatusDisplay.textContent = "STOPPED"; 
            botStatusDisplay.className = "stopped"; 
            startBtn.disabled = false; 
            stopBtn.disabled = true; 
            logMessage("Bot stopped.", "system"); 
        }

        // --- Core Bot Logic ---
        // [ --- MODIFIED: `runBotLogic` rewritten for 2-of-3 majority logic --- ]
        async function runBotLogic() {
            if (!isBotRunning && !userAccount) { return false; } 
            
            const tokenA = getSelectedTokenConfig('select-token-a');
            const tokenB = getSelectedTokenConfig('select-token-b');
            if (!tokenA || !tokenB) { 
                logMessage("Invalid tokens selected. Please add tokens if list is empty.", "warn"); 
                return isBotRunning;
            }
            
            logMessage("Running strategy check...", "info"); 
            
            try { 
                // --- 1. Find Market (if not already found) ---
                if (!currentMarket.id || !currentMarket.type) { 
                    const marketInfo = await findMarketId(); 
                    if (!marketInfo) { 
                        logMessage("Market could not be found or validated. Check token selections.", "error"); 
                        return isBotRunning; 
                    } 
                    currentMarket = marketInfo; 
                } 
                
                // --- 2. Get Current Price ---
                const currentPriceData = await getCurrentPrice(currentMarket.id, currentMarket.type); 
                if (!currentPriceData) { 
                    logMessage("Could not fetch current price.", "warn"); 
                    return isBotRunning; 
                } 
                const currentPrice = currentPriceData.price; 
                logMessage(`Current price: 1 ${tokenA.symbol} = ${currentPrice.toFixed(8)} ${tokenB.symbol}`, "info"); 
                lastPrices = [{ close: currentPrice }]; 
                
                const selectedStrategy = strategySelect.value; 

                // --- 3. Run Strategy Logic ---
                
                // --- 3A. Price Range Strategy ---
                if (selectedStrategy === 'price-range') { 
                    if (botState.inPosition) { logMessage("Price Range: In position, but strategy has no auto-sell. Sell manually or switch strategies.", "warn"); return true; }
                    const lowerBuyPrice = parseFloat(priceLower.value); 
                    const upperSellPrice = parseFloat(priceUpper.value); 
                    if (isNaN(lowerBuyPrice) || isNaN(upperSellPrice) || lowerBuyPrice <= 0 || upperSellPrice <= 0) { logMessage("Price Range: Please set a valid lower and upper price.", "warn"); return true; } 
                    
                    if (currentPrice <= lowerBuyPrice) { 
                        logMessage(`PRICE BUY TRIGGER! Price (${currentPrice.toFixed(8)}) <= ${lowerBuyPrice}.`, "success"); 
                        const bought = await executeSwap('buy'); 
                        if(bought) { botState.inPosition = true; botState.buyPrice = currentPrice; botState.strategy = 'price-range'; saveBotState(); }
                    } else if (currentPrice >= upperSellPrice) { 
                        logMessage(`PRICE SELL TRIGGER! Price (${currentPrice.toFixed(8)}) >= ${upperSellPrice}.`, "success"); 
                        await executeSwap('sell'); 
                    } else { 
                        logMessage(`Price Range: No trigger. Price is between ${lowerBuyPrice} and ${upperSellPrice}.`, "info"); 
                    } 
                
                // --- 3B. RSI Strategy ---
                } else if (selectedStrategy === 'rsi') { 
                    if (botState.inPosition) { logMessage("RSI: In position, but strategy has no auto-sell. Sell manually or switch strategies.", "warn"); return true; }
                    const prices = await getPriceHistory(currentMarket.id); 
                    if (!prices || prices.length < 14) { 
                        logMessage("RSI: Not enough historical data or history fetch failed. Skipping RSI check.", "warn"); 
                    } else { 
                        const closePrices = prices.map(p => p.close); 
                        const rsiValues = tw.rsi(closePrices, 14); 
                        const currentRSI = rsiValues[rsiValues.length - 1]; 
                        logMessage(`Current RSI: ${currentRSI.toFixed(2)}`, "info"); 
                        const buyLevel = parseFloat(rsiBuy.value); 
                        const sellLevel = parseFloat(rsiSell.value); 
                        if (currentRSI <= buyLevel) { 
                            logMessage(`RSI BUY TRIGGER! RSI (${currentRSI.toFixed(2)}) <= ${buyLevel}.`, "success"); 
                            const bought = await executeSwap('buy'); 
                            if(bought) { botState.inPosition = true; botState.buyPrice = currentPrice; botState.strategy = 'rsi'; saveBotState(); }
                        } else if (currentRSI >= sellLevel) { 
                            logMessage(`RSI SELL TRIGGER! RSI (${currentRSI.toFixed(2)}) >= ${sellLevel}.`, "success"); 
                            await executeSwap('sell');
                        } else { 
                            logMessage(`RSI: No trigger. RSI is between ${buyLevel} and ${sellLevel}.`, "info"); 
                        } 
                    } 
                
                // --- 3C. Short Term Strategy Bundle ---
                } else if (selectedStrategy === 'short-term') {
                    
                    // --- 3C.1. CHECK SELL LOGIC (IF IN POSITION) ---
                    if (botState.inPosition) {
                        
                        // Sell logic for Volume Spike (TP/SL)
                        if (botState.strategy === 'volume-spike') {
                            const takeProfit = parseFloat(volTakeProfit.value);
                            const stopLoss = parseFloat(volStopLoss.value);
                            const takeProfitPrice = botState.buyPrice * (1 + (takeProfit / 100));
                            const stopLossPrice = botState.buyPrice * (1 - (stopLoss / 100));
                            logMessage(`Vol Spike: In position at ${botState.buyPrice.toFixed(8)}. TP: ${takeProfitPrice.toFixed(8)}, SL: ${stopLossPrice.toFixed(8)}`, "system");

                            if (currentPrice >= takeProfitPrice) {
                                logMessage(`TAKE PROFIT TRIGGER! Price (${currentPrice.toFixed(8)}) >= ${takeProfitPrice.toFixed(8)}. Selling...`, "success");
                                const sold = await executeSwap('sell');
                                if(sold) { botState.inPosition = false; botState.strategy = null; botState.buyPrice = 0.0; saveBotState(); }
                            } else if (currentPrice <= stopLossPrice) {
                                logMessage(`STOP LOSS TRIGGER! Price (${currentPrice.toFixed(8)}) <= ${stopLossPrice.toFixed(8)}. Selling...`, "warn");
                                const sold = await executeSwap('sell');
                                if(sold) { botState.inPosition = false; botState.strategy = null; botState.buyPrice = 0.0; saveBotState(); }
                            } else {
                                logMessage(`Vol Spike: Holding position. Price is between TP and SL.`, "info");
                            }
                        } 

                        // Sell logic for EMA Crossover (Cross Down)
                        else if (botState.strategy === 'ema-crossover') {
                            const fastPeriod = parseInt(emaFast.value);
                            const slowPeriod = parseInt(emaSlow.value);
                            const prices = await getPriceHistory(currentMarket.id);
                            if (!prices || prices.length < slowPeriod) { logMessage(`EMA Crossover: Not enough history to check for sell signal. Holding.`, "warn"); return true; }
                            
                            const closePrices = prices.map(p => p.close);
                            const fastEMAs = tw.ema(closePrices, fastPeriod);
                            const slowEMAs = tw.ema(closePrices, slowPeriod);
                            const currentFast = fastEMAs[fastEMAs.length - 1];
                            const prevFast = fastEMAs[fastEMAs.length - 2];
                            const currentSlow = slowEMAs[slowEMAs.length - 1];
                            const prevSlow = slowEMAs[slowEMAs.length - 2];

                            if (prevFast >= prevSlow && currentFast < currentSlow) {
                                logMessage(`EMA CROSSOVER SELL TRIGGER! Fast EMA (${currentFast.toFixed(8)}) crossed below Slow EMA (${currentSlow.toFixed(8)}). Selling...`, "success");
                                const sold = await executeSwap('sell');
                                if (sold) { botState.inPosition = false; botState.strategy = null; botState.buyPrice = 0.0; saveBotState(); }
                            } else {
                                logMessage(`EMA Crossover: Holding position. No sell crossover detected.`, "info");
                            }
                        }
                    
                    // --- 3C.2. CHECK BUY LOGIC (IF NOT IN POSITION) ---
                    } else {
                        const subStrategy = shortTermStrategySelect.value;
                        
                        // Buy logic for Volume Spike (Majority Rules)
                        if (subStrategy === 'volume-spike') {
                            logMessage("Volume Spike: Looking for a buy signal (need 2/3).", "info");
                            const multiplier = parseFloat(volMultiplier.value);
                            const avgCandles = parseInt(volAvgCandles.value);
                            const trendEmaPeriod = parseInt(volTrendEma.value); 

                            const requiredCandles = Math.max(avgCandles + 1, trendEmaPeriod);
                            
                            const prices = await getPriceHistory(currentMarket.id);
                            if (!prices || prices.length < requiredCandles) {
                                logMessage(`Volume Spike: Not enough historical data. Need ${requiredCandles} candles, got ${prices ? prices.length : 0}.`, "warn");
                                return true;
                            }

                            const closePrices = prices.map(p => p.close);
                            const lastCandle = prices[prices.length - 1];
                            
                            // Signal 1: Volume Spike
                            const historySlice = prices.slice(prices.length - 1 - avgCandles, prices.length - 1);
                            const totalVolume = historySlice.reduce((acc, c) => acc + c.volume, 0);
                            const avgVolume = totalVolume / historySlice.length;
                            const isVolumeSpike = lastCandle.volume > (avgVolume * multiplier);
                            logMessage(`Volume Spike: Last 1m vol: ${lastCandle.volume.toFixed(2)}. Avg vol: ${avgVolume.toFixed(2)}.`, "system");

                            // Signal 2: Price Action (Green Candle)
                            const isPriceUp = lastCandle.close > lastCandle.open; 

                            // Signal 3: Trend Filter
                            let isUptrend = true; // Default to true if filter is off (period = 0)
                            if (trendEmaPeriod > 0) {
                                const trendEMAs = tw.ema(closePrices, trendEmaPeriod);
                                const currentTrendEma = trendEMAs[trendEMAs.length - 1];
                                isUptrend = lastCandle.close > currentTrendEma;
                                logMessage(`Volume Spike: Trend Filter (EMA ${trendEmaPeriod}): Price (${lastCandle.close.toFixed(8)}) > EMA (${currentTrendEma.toFixed(8)}) = ${isUptrend}.`, "system");
                            }

                            // [ --- NEW: Majority Rules Logic --- ]
                            let signalCount = 0;
                            if (isUptrend) signalCount++;
                            if (isVolumeSpike) signalCount++;
                            if (isPriceUp) signalCount++;

                            logMessage(`Volume Spike: Signals (Trend: ${isUptrend}, Volume: ${isVolumeSpike}, Price: ${isPriceUp}). Total: ${signalCount}/3`, "system");

                            if (signalCount >= 2) {
                                logMessage(`MAJORITY BUY TRIGGER! (${signalCount}/3 signals). Buying...`, "success");
                                const bought = await executeSwap('buy');
                                if (bought) { botState.inPosition = true; botState.buyPrice = currentPrice; botState.strategy = 'volume-spike'; saveBotState(); }
                            } else {
                                logMessage(`Volume Spike: No trigger. Need at least 2/3 signals.`, "info");
                            }
                        } 
                        
                        // Buy logic for EMA Crossover
                        else if (subStrategy === 'ema-crossover') {
                            logMessage("EMA Crossover: Looking for a buy signal.", "info");
                            const fastPeriod = parseInt(emaFast.value);
                            const slowPeriod = parseInt(emaSlow.value);
                            const prices = await getPriceHistory(currentMarket.id);
                            if (!prices || prices.length < slowPeriod) { logMessage(`EMA Crossover: Not enough historical data to check for buy signal. Need ${slowPeriod} candles.`, "warn"); return true; }
                            
                            const closePrices = prices.map(p => p.close);
                            const fastEMAs = tw.ema(closePrices, fastPeriod);
                            const slowEMAs = tw.ema(closePrices, slowPeriod);
                            const currentFast = fastEMAs[fastEMAs.length - 1];
                            const prevFast = fastEMAs[fastEMAs.length - 2];
                            const currentSlow = slowEMAs[slowEMAs.length - 1];
                            const prevSlow = slowEMAs[slowEMAs.length - 2];

                            logMessage(`EMA Crossover: Fast EMA: ${currentFast.toFixed(8)}, Slow EMA: ${currentSlow.toFixed(8)}`, "system");

                            if (prevFast <= prevSlow && currentFast > currentSlow) {
                                logMessage(`EMA CROSSOVER BUY TRIGGER! Fast EMA crossed above Slow EMA. Buying...`, "success");
                                const bought = await executeSwap('buy');
                                if (bought) { botState.inPosition = true; botState.buyPrice = 0.0; // Buy price not needed for this sell logic
                                    botState.strategy = 'ema-crossover'; saveBotState(); }
                            } else {
                                logMessage(`EMA Crossover: No buy crossover detected.`, "info");
                            }
                        }
                    }
                }
                return true; 
            } catch (e) { 
                logMessage(`Error in bot logic: ${e.message}`, "error"); 
                currentMarket = { id: null, type: null }; 
                marketConfig = { baseContract: null, quoteContract: null, isInverted: false }; 
                return false; 
            } 
        }
        
        
        async function findMarketId() {
            const tokenA = getSelectedTokenConfig('select-token-a');
            const tokenB = getSelectedTokenConfig('select-token-b');
            if (!tokenA || !tokenB) { logMessage("Please select valid tokens from the dropdowns.", "error"); return null; }
            if (tokenA.contract === tokenB.contract && tokenA.symbol === tokenB.symbol) { logMessage("Token A and Token B cannot be the same token.", "error"); return null; }
            const tokenA_contract = tokenA.contract.toLowerCase();
            const tokenA_symbol = tokenA.symbol.toUpperCase();
            const tokenB_contract = tokenB.contract.toLowerCase();
            const tokenB_symbol = tokenB.symbol.toUpperCase();
            logMessage(`Searching for market ${tokenA_symbol}@${tokenA_contract} / ${tokenB_symbol}@${tokenB_contract}...`, "system");
            let foundMarketInfo = null; 
            try {
                const url = `${ALCOR_API}/swap/pools`; 
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Swap API failed (${response.status})`);
                const swapMarkets = await response.json();
                const foundSwapMarket = swapMarkets.find(m => (m.tokenA.contract === tokenA_contract && m.tokenA.symbol === tokenA_symbol && m.tokenB.contract === tokenB_contract && m.tokenB.symbol === tokenB_symbol) || (m.tokenA.contract === tokenB_contract && m.tokenA.symbol === tokenB_symbol && m.tokenB.contract === tokenA_contract && m.tokenB.symbol === tokenA_symbol));
                if (foundSwapMarket && foundSwapMarket.id > 0) { 
                    logMessage(`Found SWAP market (LP). ID: ${foundSwapMarket.id}`, "success");
                    let base_contract, base_symbol, quote_contract, quote_symbol;
                    if (foundSwapMarket.tokenA.contract === tokenA_contract && foundSwapMarket.tokenA.symbol === tokenA_symbol) { base_contract = foundSwapMarket.tokenA.contract; base_symbol = foundSwapMarket.tokenA.symbol; quote_contract = foundSwapMarket.tokenB.contract; quote_symbol = foundSwapMarket.tokenB.symbol; } else { base_contract = foundSwapMarket.tokenB.contract; base_symbol = foundSwapMarket.tokenB.symbol; quote_contract = foundSwapMarket.tokenA.contract; quote_symbol = foundSwapMarket.tokenA.symbol; }
                    foundMarketInfo = { id: foundSwapMarket.id, type: 'swap', base_contract, base_symbol, quote_contract, quote_symbol };
                } else if (foundSwapMarket && foundSwapMarket.id === 0) {
                     logMessage(`Found SWAP market but ID is 0. Treating as invalid.`, "warn");
                } else {
                     logMessage("Did not find a valid (>0) SWAP market (LP) matching both contract and symbol.", "info");
                }
            } catch (e) { logMessage(`Could not check swap (LP) markets: ${e.message}`, "warn"); }

            if (!foundMarketInfo) {
                logMessage("No valid SWAP (LP) pool found, checking SPOT markets as fallback...", "system");
                try {
                    const url = `${ALCOR_API}/markets`; 
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Spot API failed (${response.status})`);
                    const spotMarkets = await response.json();
                    const foundSpotMarket = spotMarkets.find(m => (m.base_token.contract === tokenA_contract && m.base_token.symbol.name === tokenA_symbol && m.quote_token.contract === tokenB_contract && m.quote_token.symbol.name === tokenB_symbol) || (m.base_token.contract === tokenB_contract && m.base_token.symbol.name === tokenB_symbol && m.quote_token.contract === tokenA_contract && m.quote_token.symbol.name === tokenA_symbol));
                    if (foundSpotMarket && foundSpotMarket.id > 0) { 
                        logMessage(`Found SPOT market (using as fallback). ID: ${foundSpotMarket.id}`, "success");
                         foundMarketInfo = { id: foundSpotMarket.id, type: 'spot', base_contract: foundSpotMarket.base_token.contract, base_symbol: foundSpotMarket.base_token.symbol.name, quote_contract: foundSpotMarket.quote_token.contract, quote_symbol: foundSpotMarket.quote_token.symbol.name };
                    } else {
                         logMessage("Did not find a valid (>0) SPOT market matching both contract and symbol.", "info");
                    }
                } catch (e) { logMessage(`Could not check spot markets: ${e.message}`, "warn"); }
            }
            
            if (foundMarketInfo) {
                marketConfig.baseContract = foundMarketInfo.base_contract;
                marketConfig.quoteContract = foundMarketInfo.quote_contract;
                marketConfig.isInverted = !(foundMarketInfo.base_contract === tokenA_contract && foundMarketInfo.base_symbol === tokenA_symbol); 
                logMessage(`Validated Market: ID ${foundMarketInfo.id} (Type: ${foundMarketInfo.type}). Base: ${marketConfig.baseContract} (${foundMarketInfo.base_symbol}), Quote: ${marketConfig.quoteContract} (${foundMarketInfo.quote_symbol}), Inverted (relative to input A): ${marketConfig.isInverted}`, "system");
                return { id: foundMarketInfo.id, type: foundMarketInfo.type }; 
            } else {
                logMessage(`No valid market found for ${tokenA_symbol}@${tokenA_contract} / ${tokenB_symbol}@${tokenB_contract}`, "error");
                return null; 
            }
        }


        async function getCurrentPrice(marketId, marketType) {
            if (!marketId || !marketType) { logMessage("Cannot get current price without market ID and type.", "error"); return null; }
            logMessage(`Fetching current price for market ${marketId} (type: ${marketType})...`, "system");
            try {
                let priceRaw; 
                if (marketType === 'spot') {
                    const url = `${ALCOR_API}/markets/${marketId}`;
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Spot Market API failed (${response.status})`);
                    const marketData = await response.json();
                    if (!marketData || typeof marketData.last_price === 'undefined') throw new Error("Spot market data invalid.");
                    priceRaw = parseFloat(marketData.last_price);
                    logMessage(`Raw spot price (Base/Quote): ${priceRaw}`, "system");
                } else if (marketType === 'swap') {
                    const url = `${ALCOR_API}/swap/pools`;
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Swap Pools API failed (${response.status})`);
                    const swapPools = await response.json();
                    const pool = swapPools.find(p => p.id === marketId);
                    if (!pool) throw new Error(`Swap pool ${marketId} not found in list.`);
                    if (!pool.tokenA || !pool.tokenB || typeof pool.tokenA.quantity === 'undefined' || typeof pool.tokenB.quantity === 'undefined') {
                        throw new Error(`Reserve data (tokenA/tokenB quantity) missing or invalid format in pool object for ID ${marketId}. Cannot calculate price.`);
                    }
                    const reserveA = parseFloat(pool.tokenA.quantity);
                    const reserveB = parseFloat(pool.tokenB.quantity);
                    if (isNaN(reserveA) || isNaN(reserveB)) { throw new Error(`Parsed reserve values are invalid (NaN) for pool ID ${marketId}.`); }
                    logMessage(`Swap Pool (LP) Reserves: A=${reserveA}, B=${reserveB}`, "system");
                    if (pool.tokenA.contract === marketConfig.baseContract) {
                        if (reserveA === 0) { priceRaw = 0; logMessage("Warning: Base reserve (A) is 0. Price is effectively 0.", "warn"); } 
                        else { priceRaw = reserveB / reserveA; } 
                    } else {
                         if (reserveB === 0) { priceRaw = 0; logMessage("Warning: Base reserve (B) is 0. Price is effectively 0.", "warn"); }
                         else { priceRaw = reserveA / reserveB; }
                    }
                    logMessage(`Raw swap (LP) price (Base/Quote): ${priceRaw}`, "system");
                } else {
                    throw new Error(`Unknown market type: ${marketType}`);
                }
                if (marketConfig.isInverted) { 
                    if (priceRaw === 0) { logMessage("Warning: Raw price is 0, cannot calculate reciprocal. Using 0.", "warn"); return { price: 0 }; }
                    logMessage("Market is inverted relative to input. Calculating reciprocal price.", "system");
                    return { price: 1 / priceRaw };
                } else {
                    return { price: priceRaw };
                }
            } catch (e) {
                logMessage(`Failed to get current price: ${e.message}`, "error");
                return null;
            }
        }


        async function getPriceHistory(marketIdToFetch) { if (!marketIdToFetch) { logMessage("Cannot get price history without market ID.", "warn"); return null; } const timeframe = timeframeSelect.value; const now = Math.floor(Date.now() / 1000); const from = now - (60 * parseInt(timeframe) * 50); const resolution = timeframe; const url = `${ALCOR_API}/charts/history?market=${marketIdToFetch}&resolution=${resolution}&from=${from}&to=${now}`; logMessage(`Fetching price history for ${timeframe}m (ID: ${marketIdToFetch})...`, "system"); try { const response = await fetch(url); if (!response.ok) { if (response.status === 404) { logMessage(`No price history found for market ${marketIdToFetch} at ${timeframe}m resolution.`, "warn"); return null; } throw new Error(`History API failed (${response.status})`); } const data = await response.json(); if (!data || data.length === 0) { logMessage("No price history data returned from Alcor.", "warn"); return null; } if (marketConfig.isInverted) { logMessage("History: Market is inverted. Inverting prices.", "system"); return data.map(d => ({ time: d.time, open: d.open ? 1 / d.open : 0, high: d.low ? 1 / d.low : 0, low: d.high ? 1 / d.high : 0, close: d.close ? 1 / d.close : 0, volume: d.volume * (d.close || 0) })).filter(d => isFinite(d.open) && isFinite(d.high) && isFinite(d.low) && isFinite(d.close)); } else { return data.map(d => ({ time: d.time, open: parseFloat(d.open || 0), high: parseFloat(d.high || 0), low: parseFloat(d.low || 0), close: parseFloat(d.close || 0), volume: parseFloat(d.volume || 0) })).filter(d => isFinite(d.open) && isFinite(d.high) && isFinite(d.low) && isFinite(d.close)); } } catch (e) { logMessage(`Failed to get price history: ${e.message}`, "error"); return null; } }

        
        async function executeSwap(direction) {
            logMessage(`Attempting to execute ${direction.toUpperCase()} swap...`, "system"); 
            try {
                const tokenA = getSelectedTokenConfig('select-token-a');
                const tokenB = getSelectedTokenConfig('select-token-b');
                if (!tokenA || !tokenB) { logMessage("Selected tokens are invalid. Cannot execute swap.", "error"); return false; }
                const config = { aSymbol: tokenA.symbol.toUpperCase(), aContract: tokenA.contract, aDecimals: tokenA.decimals, bSymbol: tokenB.symbol.toUpperCase(), bContract: tokenB.contract, bDecimals: tokenB.decimals, dex: dexContract.value.trim(), amountA: parseFloat(tradeAmountA.value), amountB: parseFloat(tradeAmountB.value) };
                if (!config.aSymbol || !config.aContract || !config.bSymbol || !config.bContract || isNaN(config.aDecimals) || isNaN(config.bDecimals) || isNaN(config.amountA) || isNaN(config.amountB) || config.amountA <= 0 || config.amountB <= 0) { logMessage("Invalid token configuration or trade amounts.", "error"); return false; } 
                let actions = []; 
                if (direction === 'sell') { 
                    const totalSellAmount = config.amountA; 
                    const feeAmount = totalSellAmount * FEE_PERCENT; 
                    const userAmount = totalSellAmount - feeAmount; 
                    if (userAmount <= 0) { logMessage("Sell amount too small for fee.", "error"); return false; } 
                    const userQuantity = `${userAmount.toFixed(config.aDecimals)} ${config.aSymbol}`; 
                    const minReturnUser = (0).toFixed(config.bDecimals); 
                    const memoUser = `swap,${minReturnUser} ${config.bSymbol},${config.bContract}`; 
                    actions.push({ account: config.aContract, name: 'transfer', authorization: [{ actor: userAccount, permission: 'active' }], data: { from: userAccount, to: config.dex, quantity: userQuantity, memo: memoUser } }); 
                    const feeQuantity = `${feeAmount.toFixed(config.aDecimals)} ${config.aSymbol}`; 
                    if (feeAmount > 0) { actions.push({ account: config.aContract, name: 'transfer', authorization: [{ actor: userAccount, permission: 'active' }], data: { from: userAccount, to: FEE_RECEIVER, quantity: feeQuantity, memo: `0.1% fee from WAX TA Trader` } }); logMessage(`ACTION (Fee): Transfer ${feeQuantity} to ${FEE_RECEIVER}`, "info"); } 
                    logMessage(`ACTION (User): Transfer ${userQuantity} to ${config.dex} | Memo: ${memoUser}`, "info"); 
                } else if (direction === 'buy') { 
                    const quantity = `${config.amountB.toFixed(config.bDecimals)} ${config.bSymbol}`; 
                    const minReturn = (0).toFixed(config.aDecimals); 
                    const memo = `swap,${minReturn} ${config.aSymbol},${config.aContract}`; 
                    actions.push({ account: config.bContract, name: 'transfer', authorization: [{ actor: userAccount, permission: 'active' }], data: { from: userAccount, to: config.dex, quantity: quantity, memo: memo } }); 
                    logMessage(`ACTION: Transfer ${quantity} to ${config.dex} | Memo: ${memo}`, "info"); 
                } 
                const result = await wax.api.transact({ actions }, { blocksBehind: 3, expireSeconds: 1200 }); 
                logMessage(`Swap successful! TxID: ${result.transaction_id.substring(0, 12)}...`, "success"); 
                if (direction === 'buy') { 
                    updatePnl('buy', config.amountB); 
                } else if (direction === 'sell') { 
                    if (lastPrices.length > 0) { 
                        const currentPrice = lastPrices[lastPrices.length - 1].close; 
                        const userAmountSold = config.amountA * (1 - FEE_PERCENT); 
                        const estimatedReceivedB = userAmountSold * currentPrice; 
                        logMessage(`Est. ${estimatedReceivedB.toFixed(config.bDecimals)} ${config.bSymbol} received.`, "info"); 
                        updatePnl('sell', estimatedReceivedB); 
                    } else { 
                        logMessage(`Could not estimate PnL for sell trade, no current price data available.`, "warn"); 
                    } 
                } 
                return true;
            } catch (e) { 
                let errorMessage = e.message; 
                try { 
                    const errorJson = JSON.parse(e.message); 
                    if (errorJson.error?.details?.length > 0) errorMessage = errorJson.error.details[0].message; 
                    else if (errorJson.error?.what) errorMessage = errorJson.error.what; 
                } catch (parseError) {} 
                logMessage(`Swap failed: ${errorMessage}`, "error"); 
                return false; 
            } 
        }
    </script>
</body>
</html>
