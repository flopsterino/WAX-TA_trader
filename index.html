<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WAX TA Trading Bot</title>
    <script src="https://cdn.jsdelivr.net/gh/flopsterino/WAX-TA_trader@main/waxjs.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/7.12.1/polyfill.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/trendyways/trendyways.min.js" defer></script>

    <style>
        /* --- Base Styles --- */
        :root {
            --bg-primary: #1a1c23;
            --bg-secondary: #242731;
            --bg-tertiary: #3a3f4c;
            --border-color: #4a5160;
            --text-primary: #e0e2e8;
            --text-secondary: #a0a6b3;
            --text-cyan: #22d3ee;
            --text-green: #34d399;
            --text-red: #f87171;
            --text-yellow: #facc15;
            --text-blue: #60a5fa;
            --accent-cyan: #06b6d4;
            --accent-cyan-hover: #0891b2;
            --accent-green: #10b981;
            --accent-green-hover: #059669;
            --accent-red: #ef4444;
            --accent-red-hover: #dc2626;
            --accent-blue: #3b82f6;
            --accent-blue-hover: #2563eb;
            --shadow-color: rgba(0, 0, 0, 0.2);
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --font-mono: 'Courier New', Courier, monospace;
        }

        /* --- Global Resets & Body --- */
        * {
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: var(--font-sans);
            margin: 0;
            padding: 1rem;
            min-height: 100vh;
        }

        @media (min-width: 768px) {
            body {
                padding: 2rem;
            }
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        h1 {
            font-size: 2.25rem;
            font-weight: 700;
            text-align: center;
            margin: 0 0 1rem 0;
            color: var(--text-cyan);
        }

        h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0 0 1rem 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
            color: var(--text-primary);
        }

        /* --- App Structure --- */
        .app-section {
            background-color: var(--bg-secondary);
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow-color);
        }

        .alert {
            padding: 1rem;
            border-radius: 6px;
            border-left: 4px solid;
        }
        .alert-critical {
            background-color: #450a0a;
            border-color: var(--text-red);
            color: #fecaca;
        }
        .alert-critical p {
            margin: 0;
        }
        .alert-critical strong {
            color: white;
            font-weight: 600;
        }

        /* --- Forms & Inputs --- */
        fieldset {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 1rem 1.5rem;
            margin-bottom: 1rem;
        }
        legend {
            padding: 0 0.5rem;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 1.1rem;
        }
        .form-grid {
            display: grid;
            grid-template-columns: repeat(1, 1fr);
            gap: 1rem;
        }
        @media (min-width: 768px) {
            .form-grid-cols-3 {
                grid-template-columns: repeat(3, 1fr);
            }
            .form-grid-cols-2 {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-secondary);
        }
        label .default-text {
            font-size: 0.75rem;
            color: var(--text-cyan);
            margin-left: 0.25rem;
        }
        input[type="text"],
        input[type="number"],
        select {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 6px;
            padding: 0.75rem 1rem;
            width: 100%;
            transition: border-color 0.2s, box-shadow 0.2s;
            font-size: 0.9rem;
        }
        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: var(--accent-cyan);
            box-shadow: 0 0 0 3px rgba(6, 182, 212, 0.3);
        }
        .note {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        /* --- Buttons --- */
        button {
            font-weight: 600;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s, opacity 0.2s;
            width: 100%;
            font-size: 1rem;
        }
        button.primary {
            background-color: var(--accent-cyan);
            color: var(--bg-primary);
        }
        button.primary:hover {
            background-color: var(--accent-cyan-hover);
        }
        button.secondary {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            width: auto;
            font-size: 0.8rem;
            font-weight: 500;
            padding: 0.25rem 0.75rem;
        }
        button.secondary:hover {
            background-color: var(--border-color);
        }
        /* Verify button styles removed as button is gone */
        button.start {
            background-color: var(--accent-green);
            color: white;
        }
        button.start:hover {
            background-color: var(--accent-green-hover);
        }
        button.stop {
            background-color: var(--accent-red);
            color: white;
        }
        button.stop:hover {
            background-color: var(--accent-red-hover);
        }
        button:disabled {
            background-color: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: not-allowed;
            opacity: 0.7;
        }
        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        /* --- Status & Log --- */
        .status-grid {
            margin-top: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .status-item .label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        .status-item .value {
            font-weight: 700;
            font-size: 1rem;
        }
        .status-item .value-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        #user-account { color: var(--text-green); }
        #pnl-display.positive { color: var(--text-green); }
        #pnl-display.negative { color: var(--text-red); }
        #pnl-display.neutral { color: var(--text-secondary); }
        .bot-status-container {
            text-align: center;
        }
        #bot-status {
            font-weight: 700;
            font-size: 1.1rem;
        }
        #bot-status.running { color: var(--text-green); }
        #bot-status.stopped { color: var(--text-red); }
        /* market-status styles removed as element is gone */

        /* --- Log Output --- */
        #log-output {
            font-family: var(--font-mono);
            max-height: 400px;
            overflow-y: auto;
            background-color: var(--bg-primary); /* Darker than section */
            border: 1px solid var(--border-color);
            padding: 1rem;
            border-radius: 6px;
            font-size: 0.875rem;
        }
        #log-output p {
            margin: 0 0 0.35rem 0;
            border-bottom: 1px solid var(--bg-tertiary);
            padding-bottom: 0.35rem;
            word-break: break-all;
            line-height: 1.6;
        }
        #log-output p:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        #log-output .log-time { color: var(--text-secondary); margin-right: 0.5rem; }
        #log-output .log-info { color: var(--text-primary); }
        #log-output .log-error { color: var(--text-red); }
        #log-output .log-success { color: var(--text-green); }
        #log-output .log-warn { color: var(--text-yellow); }
        #log-output .log-system { color: var(--text-cyan); }
        #log-output .log-idle { color: var(--text-secondary); }

        /* --- Strategy Settings --- */
        .strategy-settings.hidden {
            display: none;
        }
        hr {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 1.5rem 0;
        }

        /* --- Modal --- */
        .modal-overlay {
            display: none; /* Changed from hidden */
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.75);
            align-items: center;
            justify-content: center;
            z-index: 50;
            padding: 1rem;
        }
        .modal-overlay.visible {
            display: flex;
        }
        .modal-content {
            background-color: var(--bg-secondary);
            width: 100%;
            max-width: 500px;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 10px 30px var(--shadow-color);
            position: relative;
        }
        .modal-close-btn {
            position: absolute;
            top: 0.75rem;
            right: 1.25rem;
            color: var(--text-secondary);
            font-size: 2.5rem;
            font-weight: 300;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            width: auto;
            line-height: 1;
        }
        .modal-close-btn:hover {
            color: var(--text-primary);
        }
        .modal-content h2 {
            text-align: center;
            color: var(--text-cyan);
            margin-top: 0;
            margin-bottom: 1.5rem;
            border: none;
        }
        .modal-summary {
            background-color: var(--bg-tertiary);
            padding: 1.5rem;
            border-radius: 6px;
            margin-bottom: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }
        .modal-summary-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-summary-item .label {
            color: var(--text-secondary);
        }
        .modal-summary-item .value {
            font-weight: 600;
        }
        #share-wallet { color: var(--text-cyan); }
        #share-spent { color: var(--text-red); }
        #share-received { color: var(--text-green); }
        .modal-summary hr {
            margin: 0.5rem 0;
        }
        .modal-summary-total {
            font-size: 1.25rem;
            font-weight: 700;
        }
        #share-pnl.positive { color: var(--text-green); }
        #share-pnl.negative { color: var(--text-red); }
        #share-pnl.neutral { color: var(--text-secondary); }

        #copy-share-btn {
            background-color: var(--accent-cyan);
            color: var(--bg-primary);
        }
        #copy-share-btn:hover {
            background-color: var(--accent-cyan-hover);
        }
        #share-text {
            position: absolute;
            left: -9999px;
            opacity: 0;
        }

    </style>
</head>
<body>

    <div class="container">
        <h1>WAX TA Trading Bot</h1>

        <div class="alert alert-critical" role="alert">
            <p><strong>High Risk: Use at Your Own Risk</strong></p>
            <p>This is an educational tool. Automated trading is extremely risky and can lead to a total loss of funds. You are solely responsible for your actions. A 0.1% fee on all sell trades is sent to `qu.ug.wam`.</p>
        </div>

        <div class="app-section">
            <h2>Step 1: Connect & Status</h2>
            <button id="login-btn" class="primary">
                Login with WAX Wallet
            </button>
            <div class="status-grid">
                <div class="status-item">
                    <span class="label">Wallet:</span>
                    <strong id="user-account" class="value">Not Logged In</strong>
                </div>
                <div class="status-item">
                    <span class="label">Your PnL:</span>
                    <div class="value-group">
                        <span id="pnl-display" class="value neutral">0.00</span>
                        <button id="share-pnl-btn" class="secondary">Share</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="app-section">
            <h2>Step 2: Configure Tokens</h2>
            
            <fieldset>
                <legend>Token A (The token you want to trade)</legend>
                <div class="form-grid form-grid-cols-3">
                    <div class="form-group">
                        <label for="token-a-symbol">Symbol</label>
                        <input type="text" id="token-a-symbol" placeholder="e.g., TLM">
                    </div>
                    <div class="form-group">
                        <label for="token-a-contract">Contract</label>
                        <input type="text" id="token-a-contract" placeholder="e.g., alien.worlds">
                    </div>
                    <div class="form-group">
                        <label for="token-a-decimals">Decimals</label>
                        <input type="number" id="token-a-decimals" value="4">
                    </div>
                </div>
            </fieldset>

            <fieldset>
                <legend>Token B (e.g., Bridged USDC)</legend>
                <div class="form-grid form-grid-cols-3">
                    <div class="form-group">
                        <label for="token-b-symbol">Symbol</label>
                        <input type="text" id="token-b-symbol" placeholder="e.g., WAXUSDC">
                    </div>
                    <div class="form-group">
                        <label for="token-b-contract">Contract</label>
                        <input type="text" id="token-b-contract" placeholder="e.g., usdc.token">
                    </div>
                    <div class="form-group">
                        <label for="token-b-decimals">Decimals</label>
                        <input type="number" id="token-b-decimals" value="6">
                    </div>
                </div>
            </fieldset>

            </div>
        
        <div class="app-section">
            <h2>Step 3: Define Strategy</h2>
            
            <div class="form-grid form-grid-cols-2">
                <div class="form-group">
                    <label for="strategy-select">Trading Strategy</label>
                    <select id="strategy-select">
                        <option value="rsi">RSI Strategy (Default)</option>
                        <option value="price-range">Price Range Strategy</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="timeframe-select">Chart Timeframe</label>
                    <select id="timeframe-select">
                        <option value="1">1 Minute</option>
                        <option value="5">5 Minutes</option>
                        <option value="15">15 Minutes</option>
                        <option value="30">30 Minutes</option>
                        <option value="60" selected>1 Hour</option>
                        <option value="240">4 Hours</option>
                        <option value="1440">1 Day</option>
                    </select>
                </div>
            </div>

            <div id="rsi-settings" class="strategy-settings form-grid form-grid-cols-2" style="margin-top: 1rem;">
                <div class="form-group">
                    <label for="rsi-buy">
                        Buy Token A when 14-period RSI is below:
                        <span class="default-text">(Default: 30)</span>
                    </label>
                    <input type="number" id="rsi-buy" value="30">
                </div>
                <div class="form-group">
                    <label for="rsi-sell">
                        Sell Token A when 14-period RSI is above:
                        <span class="default-text">(Default: 70)</span>
                    </label>
                    <input type="number" id="rsi-sell" value="70">
                </div>
            </div>

            <div id="price-range-settings" class="strategy-settings hidden form-grid form-grid-cols-2" style="margin-top: 1rem;">
                <div class="form-group">
                    <label for="price-lower">
                        Lower Buy Price (in Token B)
                    </label>
                    <input type="number" id="price-lower" placeholder="e.g., 0.05">
                </div>
                <div class="form-group">
                    <label for="price-upper">
                        Upper Sell Price (in Token B)
                    </label>
                    <input type="number" id="price-upper" placeholder="e.g., 0.10">
                </div>
            </div>

            <hr>
            <div class="form-grid form-grid-cols-2">
                <div class="form-group">
                    <label for="trade-amount-a">Amount of Token A to SELL:</label>
                    <input type="number" id="trade-amount-a" value="100">
                </div>
                <div class="form-group">
                    <label for="trade-amount-b">Amount of Token B to spend on BUY:</label>
                    <input type="number" id="trade-amount-b" value="10">
                </div>
            </div>

            <div class="form-group" style="margin-top: 1rem;">
                <label for="dex-contract">DEX Router Contract (Alcor is default)</label>
                <input type="text" id="dex-contract" value="alcor.swap">
                <p class="note">
                    Note: The <code>alcor.swap</code> router automatically uses both Liquidity Pools (LPs) and the spot market to find the best trade price.
                </p>
            </div>
        </div>

        <div class="app-section">
            <h2>Step 4: Control Panel</h2>
            <div class="button-grid">
                <button id="start-btn" class="start">
                    Start Bot
                </button>
                <button id="stop-btn" class="stop" disabled>
                    Stop Bot
                </button>
            </div>
            <div class="bot-status-container">
                <span style="color: var(--text-secondary);">Status:</span>
                <strong id="bot-status" class="stopped">STOPPED</strong>
            </div>
        </div>

        <div class="app-section">
            <h2>Bot Log</h2>
            <div id="log-output">
                <p class="log-idle">Bot is idle. Please log in, configure settings, and press Start.</p>
            </div>
        </div>

    </div> <div id="share-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="close-share-modal-btn" class="modal-close-btn">&times;</button>
            <h2>My Trading Bot PnL</h2>
            
            <div class="modal-summary">
                <div class="modal-summary-item">
                    <span class="label">Wallet:</span>
                    <span id="share-wallet" class="value">...</span>
                </div>
                <div class="modal-summary-item">
                    <span class="label">Total Spent (B):</span>
                    <span id="share-spent" class="value">0.00</span>
                </div>
                <div class="modal-summary-item">
                    <span class="label">Total Received (B):</span>
                    <span id="share-received" class="value">0.00</span>
                </div>
                <hr>
                <div class="modal-summary-item modal-summary-total">
                    <span class="label">Net PnL:</span>
                    <span id="share-pnl" class="value neutral">0.00</span>
                </div>
            </div>

            <textarea id="share-text"></textarea> <button id="copy-share-btn">
                Copy Sharable Text
            </button>
        </div>
    </div>


    <script>
        // --- Global Variables ---
        let wax;
        let userAccount = null;
        let botInterval = null;
        let isBotRunning = false;
        let lastPrices = []; // Store prices for PnL estimation
        let pnlData = { totalSpentTokenB: 0, totalReceivedTokenB: 0, pnl: 0 };
        
        let marketId = null; // Will be fetched from API
        let marketConfig = { baseContract: null, quoteContract: null }; // To check for inverted price
        
        let tw = null; // This will be our new library (trendyways)
        
        const WAX_RPC_ENDPOINT = 'https://wax.greymass.com';
        const FEE_RECEIVER = 'qu.ug.wam';
        const FEE_PERCENT = 0.001; // 0.1%
        const ALCOR_API = 'https://wax.alcor.exchange/api/v2';


        // --- DOM Elements (to be assigned in init) ---
        let loginBtn, userAccountDisplay, startBtn, stopBtn, botStatusDisplay, logOutput, pnlDisplay;
        let shareModal, sharePnlBtn, closeShareModalBtn, shareWallet, shareSpent, shareReceived, sharePnl, copyShareBtn, shareText;
        let tokenASymbol, tokenAContract, tokenADecimals, tokenBSymbol, tokenBContract, tokenBDecimals; // verifyMarketBtn, marketStatus removed
        let timeframeSelect, dexContract, tradeAmountA, tradeAmountB;
        let strategySelect, rsiSettings, priceRangeSettings, rsiBuy, rsiSell, priceLower, priceUpper;

        /**
         * Assigns all DOM elements to variables
         */
        function assignDomElements() {
            loginBtn = document.getElementById('login-btn');
            userAccountDisplay = document.getElementById('user-account');
            startBtn = document.getElementById('start-btn');
            stopBtn = document.getElementById('stop-btn');
            botStatusDisplay = document.getElementById('bot-status');
            logOutput = document.getElementById('log-output');
            pnlDisplay = document.getElementById('pnl-display');
            
            shareModal = document.getElementById('share-modal');
            sharePnlBtn = document.getElementById('share-pnl-btn');
            closeShareModalBtn = document.getElementById('close-share-modal-btn');
            shareWallet = document.getElementById('share-wallet');
            shareSpent = document.getElementById('share-spent');
            shareReceived = document.getElementById('share-received');
            sharePnl = document.getElementById('share-pnl');
            copyShareBtn = document.getElementById('copy-share-btn');
            shareText = document.getElementById('share-text');

            tokenASymbol = document.getElementById('token-a-symbol');
            tokenAContract = document.getElementById('token-a-contract');
            tokenADecimals = document.getElementById('token-a-decimals');
            tokenBSymbol = document.getElementById('token-b-symbol');
            tokenBContract = document.getElementById('token-b-contract');
            tokenBDecimals = document.getElementById('token-b-decimals');
            // verifyMarketBtn = document.getElementById('verify-market-btn'); // Removed
            // marketStatus = document.getElementById('market-status'); // Removed
            timeframeSelect = document.getElementById('timeframe-select');
            dexContract = document.getElementById('dex-contract');
            tradeAmountA = document.getElementById('trade-amount-a');
            tradeAmountB = document.getElementById('trade-amount-b');

            strategySelect = document.getElementById('strategy-select');
            rsiSettings = document.getElementById('rsi-settings');
            priceRangeSettings = document.getElementById('price-range-settings');
            rsiBuy = document.getElementById('rsi-buy');
            rsiSell = document.getElementById('rsi-sell');
            priceLower = document.getElementById('price-lower');
            priceUpper = document.getElementById('price-upper');
        }


        // --- PnL Functions ---

        /**
         * Loads PnL data from localStorage
         */
        function loadPnlFromStorage() {
            const savedData = localStorage.getItem('waxTraderPnl');
            if (savedData) {
                pnlData = JSON.parse(savedData);
                logMessage("Loaded PnL data from storage.", "system");
            } else {
                logMessage("No PnL data found, starting fresh.", "system");
            }
            updatePnlDisplay();
        }

        /**
         * Saves PnL data to localStorage
         */
        function savePnlToStorage() {
            localStorage.setItem('waxTraderPnl', JSON.stringify(pnlData));
        }

        /**
         * Updates PnL data and saves to localStorage
         */
        function updatePnl(direction, amountB) {
            if (direction === 'buy') {
                pnlData.totalSpentTokenB += amountB;
            } else if (direction === 'sell') {
                pnlData.totalReceivedTokenB += amountB;
            }
            pnlData.pnl = pnlData.totalReceivedTokenB - pnlData.totalSpentTokenB;

            savePnlToStorage();
            updatePnlDisplay();
            logMessage(`PnL updated: ${pnlData.pnl.toFixed(4)}`, "success");
        }

        /**
         * Updates the PnL text in the UI
         */
        function updatePnlDisplay() {
            const pnlValue = pnlData.pnl || 0;
            const tokenSymbol = tokenBSymbol.value.trim().toUpperCase() || 'Token B';
            
            pnlDisplay.textContent = `${pnlValue.toFixed(4)} ${tokenSymbol}`;
            if (pnlValue > 0) {
                pnlDisplay.className = "value positive";
            } else if (pnlValue < 0) {
                pnlDisplay.className = "value negative";
            } else {
                pnlDisplay.className = "value neutral";
            }
        }

        // --- Share Modal Functions ---
        
        function openShareModal() {
            const tokenSymbol = tokenBSymbol.value.trim().toUpperCase() || 'Token B';
            const pnlValue = pnlData.pnl || 0;
            
            // Update modal content
            shareWallet.textContent = userAccount || 'N/A';
            shareSpent.textContent = `${pnlData.totalSpentTokenB.toFixed(4)} ${tokenSymbol}`;
            shareReceived.textContent = `${pnlData.totalReceivedTokenB.toFixed(4)} ${tokenSymbol}`;
            sharePnl.textContent = `${pnlValue.toFixed(4)} ${tokenSymbol}`;
            
            if (pnlValue > 0) {
                sharePnl.className = "value positive";
            } else if (pnlValue < 0) {
                sharePnl.className = "value negative";
            } else {
                sharePnl.className = "value neutral";
            }
            
            // Prepare text for copying
            const textToCopy = `
ðŸ“ˆ My WAX TA Bot Report ðŸ“ˆ
-------------------------
Wallet: ${userAccount}
Net PnL: ${pnlValue.toFixed(4)} ${tokenSymbol}
(Spent: ${pnlData.totalSpentTokenB.toFixed(4)} | Received: ${pnlData.totalReceivedTokenB.toFixed(4)})
-------------------------
Bot by: qu.ug.wam
            `;
            shareText.value = textToCopy.trim(); // Set for copy button
            
            shareModal.classList.add('visible');
        }

        function closeShareModal() {
            shareModal.classList.remove('visible');
        }

        function copyShareText() {
            // Use execCommand for broader compatibility in iframes
            shareText.select();
            shareText.setSelectionRange(0, 99999); // For mobile
            try {
                document.execCommand('copy');
                copyShareBtn.textContent = 'Copied!';
                setTimeout(() => { copyShareBtn.textContent = 'Copy Sharable Text'; }, 2000);
            } catch (err) {
                logMessage('Failed to copy share text.', 'error');
            }
        }

        // --- Core Functions ---

        /**
         * Logs a message to the UI
         */
        function logMessage(message, level = "info") {
            if (!logOutput) { // Handle logs before DOM is ready
                console.log(`[${level.toUpperCase()}] ${message}`);
                return;
            }
            const p = document.createElement('p');
            const timestamp = new Date().toLocaleTimeString();
            
            let levelClass = "log-info";
            if (level === "error") levelClass = "log-error";
            if (level === "success") levelClass = "log-success";
            if (level === "warn") levelClass = "log-warn";
            if (level === "system") levelClass = "log-system";

            p.className = levelClass;
            p.innerHTML = `<span class="log-time">[${timestamp}]</span> ${message}`;
            
            const placeholder = logOutput.querySelector('.log-idle');
            if (placeholder) placeholder.remove();

            logOutput.prepend(p);
        }

        /**
         * Toggles the strategy settings visibility
         */
        function toggleStrategySettings() {
            const selectedStrategy = strategySelect.value;
            if (selectedStrategy === 'rsi') {
                rsiSettings.classList.remove('hidden');
                priceRangeSettings.classList.add('hidden');
            } else if (selectedStrategy === 'price-range') {
                rsiSettings.classList.add('hidden');
                priceRangeSettings.classList.remove('hidden');
            }
        }

        /**
         * Initializes the app on window load
         */
        window.addEventListener('load', () => {
            // 0. Assign all DOM elements
            assignDomElements();

            // Check if libraries loaded
            if (typeof waxjs === 'undefined') {
                logMessage("FATAL: waxjs library failed to load. Check script tag.", "error");
                return;
            }
            
            if (typeof tw === 'undefined') {
                logMessage("FATAL: trendyways library (tw) failed to load.", "error");
                return;
            }

            // 1. Initialize waxjs
            wax = new waxjs.WaxJS({
                rpcEndpoint: WAX_RPC_ENDPOINT,
                tryAutoLogin: false
            });

            // 2. Load PnL from storage
            loadPnlFromStorage();

            // 3. Add Event Listeners
            loginBtn.addEventListener('click', login);
            
            // Verify market button listener removed
            
            startBtn.addEventListener('click', startBot);
            stopBtn.addEventListener('click', stopBot);
            sharePnlBtn.addEventListener('click', openShareModal);
            closeShareModalBtn.addEventListener('click', closeShareModal);
            copyShareBtn.addEventListener('click', copyShareText);
            strategySelect.addEventListener('change', toggleStrategySettings);
            
            // Close modal on outside click
            shareModal.addEventListener('click', (e) => {
                if (e.target === shareModal) {
                    closeShareModal();
                }
            });

            logMessage("App initialized. Please log in.", "system");
            logMessage("Market verification disabled. Ensure token contracts are correct before starting.", "warn");
        
            // Set initial strategy visibility
            toggleStrategySettings();
        });

        /**
         * Handles WAX Wallet Login
         */
        async function login() {
            try {
                logMessage("Attempting login...", "system");
                userAccount = await wax.login();
                userAccountDisplay.textContent = userAccount;
                loginBtn.disabled = true;
                loginBtn.textContent = "Logged In";
                logMessage(`Logged in as: ${userAccount}`, "success");
            } catch (e) {
                logMessage(`Login failed: ${e.message}`, "error");
            }
        }

        /**
         * Starts the trading bot
         */
        async function startBot() {
            if (!userAccount) {
                logMessage("Please log in before starting the bot.", "error");
                return;
            }
            if (isBotRunning) return;

            logMessage("Bot starting... Running first check to find market.", "system");
            
            // Run the first logic check manually to find the market ID.
            const successfulFirstRun = await runBotLogic();
            
            if (successfulFirstRun) {
                isBotRunning = true;
                botStatusDisplay.textContent = "RUNNING";
                botStatusDisplay.className = "running";
                startBtn.disabled = true;
                stopBtn.disabled = false;
                // verifyMarketBtn.disabled = true; // Button is removed, no need to disable
                
                logMessage("Bot started successfully!", "success");
                
                const checkInterval = parseInt(timeframeSelect.value) * 60 * 1000;
                botInterval = setInterval(runBotLogic, Math.max(60000, checkInterval)); // At least 60s
            } else {
                logMessage("Bot failed to start. Check contracts and symbols.", "error");
            }
        }

        /**
         * Stops the trading bot
         */
        function stopBot() {
            if (!isBotRunning) return;

            isBotRunning = false;
            clearInterval(botInterval);
            marketId = null; // Clear the market ID
            marketConfig = { baseContract: null, quoteContract: null };
            // marketStatus element removed
            botStatusDisplay.textContent = "STOPPED";
            botStatusDisplay.className = "stopped";
            startBtn.disabled = false;
            stopBtn.disabled = true;
            // verifyMarketBtn element removed
            logMessage("Bot stopped.", "system");
        }

        /**
         * The main logic loop for the bot
         */
        async function runBotLogic() {
            // Allow this to run once on start even if isBotRunning is false
            if (!isBotRunning && !userAccount) {
                 return false; // Don't run if not logged in
            }
            
            logMessage("Running strategy check...", "info");

            try {
                // 1. Get Price History (also finds marketId if needed)
                const prices = await getPriceHistory();
                if (!prices || prices.length < 1) {
                    logMessage("No price data available.", "warn");
                    // If this was the first run (bot not running yet), it failed
                    return isBotRunning; // Return true if bot was already running, false otherwise
                }
                lastPrices = prices; // Save for PnL
                
                // 2. Get current state
                const selectedStrategy = strategySelect.value;
                const currentPrice = prices[prices.length - 1].close; 
                logMessage(`Current price: 1 ${tokenASymbol.value.trim().toUpperCase()} = ${currentPrice.toFixed(8)} ${tokenBSymbol.value.trim().toUpperCase()}`, "info");

                // 3. Run selected strategy
                if (selectedStrategy === 'rsi') {
                    if (prices.length < 14) {
                        logMessage("Not enough price data for RSI (need 14 periods).", "warn");
                        return true; // Still a successful run, just not enough data
                    }
                    
                    const closePrices = prices.map(p => p.close);
                    const rsiValues = tw.rsi(closePrices, 14); 
                    const currentRSI = rsiValues[rsiValues.length - 1];
                    logMessage(`Current RSI: ${currentRSI.toFixed(2)}`, "info");

                    const buyLevel = parseFloat(rsiBuy.value);
                    const sellLevel = parseFloat(rsiSell.value);

                    if (currentRSI <= buyLevel) {
                        logMessage(`RSI BUY TRIGGER! RSI (${currentRSI.toFixed(2)}) is <= ${buyLevel}.`, "success");
                        await executeSwap('buy');
                    } else if (currentRSI >= sellLevel) {
                        logMessage(`RSI SELL TRIGGER! RSI (${currentRSI.toFixed(2)}) is >= ${sellLevel}.`, "success");
                        await executeSwap('sell');
                    } else {
                        logMessage(`RSI: No trigger. RSI is between ${buyLevel} and ${sellLevel}.`, "info");
                    }
                
                } else if (selectedStrategy === 'price-range') {
                    const lowerBuyPrice = parseFloat(priceLower.value);
                    const upperSellPrice = parseFloat(priceUpper.value);

                    if (isNaN(lowerBuyPrice) || isNaN(upperSellPrice) || lowerBuyPrice <= 0 || upperSellPrice <= 0) {
                        logMessage("Price Range: Please set a valid lower and upper price.", "warn");
                        return true; // Successful run, just misconfigured
                    }

                    if (currentPrice <= lowerBuyPrice) {
                        logMessage(`PRICE BUY TRIGGER! Price (${currentPrice.toFixed(8)}) is <= ${lowerBuyPrice}.`, "success");
                        await executeSwap('buy');
                    } else if (currentPrice >= upperSellPrice) {
                        logMessage(`PRICE SELL TRIGGER! Price (${currentPrice.toFixed(8)}) is >= ${upperSellPrice}.`, "success");
                        await executeSwap('sell');
                    } else {
                        logMessage(`Price Range: No trigger. Price is between ${lowerBuyPrice} and ${upperSellPrice}.`, "info");
                    }
                }
                
                return true; // Successful run

            } catch (e) {
                logMessage(`Error in bot logic: ${e.message}`, "error");
                return false; // Failed run
            }
        }
        
        /**
         * Finds the market ID from *any* Alcor endpoint (Swap or Spot)
         */
        async function findMarketId() {
            if (marketId) return marketId; // Return cached ID if available
            
            const tokenA = tokenAContract.value.trim();
            const tokenB = tokenBContract.value.trim();
            if (!tokenA || !tokenB) {
                 logMessage("Token contracts cannot be empty.", "error");
                 return null;
            }
            logMessage(`Searching for market ${tokenA} / ${tokenB}...`, "system");

            // 1. Try SWAP pools
            try {
                const url = `${ALCOR_API}/swap/pools`; // Corrected endpoint
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Swap API failed (${response.status})`);
                
                const swapMarkets = await response.json();
                const foundSwapMarket = swapMarkets.find(m =>
                    (m.tokenA.contract === tokenA && m.tokenB.contract === tokenB) ||
                    (m.tokenA.contract === tokenB && m.tokenB.contract === tokenA)
                );
                
                if (foundSwapMarket) {
                    logMessage(`Found SWAP market. ID: ${foundSwapMarket.id}`, "success");
                    marketId = foundSwapMarket.id;
                    // Determine base/quote based on the order they appeared in the found market
                    if (foundSwapMarket.tokenA.contract === tokenA) {
                         marketConfig.baseContract = foundSwapMarket.tokenA.contract; 
                         marketConfig.quoteContract = foundSwapMarket.tokenB.contract;
                    } else {
                         marketConfig.baseContract = foundSwapMarket.tokenB.contract;
                         marketConfig.quoteContract = foundSwapMarket.tokenA.contract;
                    }
                    return marketId;
                }
            } catch (e) {
                logMessage(`Could not check swap markets: ${e.message}`, "warn");
            }

            // 2. Try SPOT markets
            try {
                const url = `${ALCOR_API}/markets`; // Corrected endpoint (plural)
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Spot API failed (${response.status})`);
                
                const spotMarkets = await response.json();
                const foundSpotMarket = spotMarkets.find(m =>
                    (m.base_token.contract === tokenA && m.quote_token.contract === tokenB) ||
                    (m.base_token.contract === tokenB && m.quote_token.contract === tokenA)
                );
                
                if (foundSpotMarket) {
                    logMessage(`Found SPOT market. ID: ${foundSpotMarket.id}`, "success");
                    marketId = foundSpotMarket.id;
                    marketConfig.baseContract = foundSpotMarket.base_token.contract;
                    marketConfig.quoteContract = foundSpotMarket.quote_token.contract;
                    return marketId;
                }
            } catch (e) {
                logMessage(`Could not check spot markets: ${e.message}`, "warn");
            }
            
            // 3. If nothing is found
            logMessage(`No market found for ${tokenA} / ${tokenB} on Spot or Swap.`, "error");
            return null;
        }


        /**
         * Gets price history from Alcor API
         */
        async function getPriceHistory() {
            // Find marketId if we don't have it yet
            if (!marketId) {
                const foundId = await findMarketId();
                if (!foundId) {
                    throw new Error("Market ID could not be found. Check token contracts.");
                }
            }
            
            const timeframe = timeframeSelect.value;
            const now = Math.floor(Date.now() / 1000);
            const from = now - (60 * parseInt(timeframe) * 200); // Get 200 periods
            const resolution = timeframe; // Alcor uses minutes
            
            const apiUrl = `${ALCOR_API}/charts/history?market=${marketId}&resolution=${resolution}&from=${from}&to=${now}`;
            const url = apiUrl;

            logMessage(`Fetching prices from Alcor (ID: ${marketId}, TF: ${timeframe}m)...`, "system");
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    // Handle 404 specifically - might mean no history for this pair/timeframe
                    if (response.status === 404) {
                         logMessage(`No price history found for market ${marketId} at ${timeframe}m resolution.`, "warn");
                         return null;
                    }
                    throw new Error(`API request failed with status ${response.status}.`);
                }
                const data = await response.json();
                if (!data || data.length === 0) {
                    logMessage("No price data returned from Alcor for this timeframe.", "warn");
                    return null;
                }
                
                // Check if market is inverted (Price of B in terms of A)
                // We use Token A contract from input to check against base found by findMarketId
                const tokenAContractInput = tokenAContract.value.trim();
                const isInverted = marketConfig.baseContract !== tokenAContractInput; 
                
                if (isInverted) {
                     // Ensure the base IS actually Token B, otherwise something is wrong
                    if (marketConfig.baseContract !== tokenBContract.value.trim()) {
                         logMessage(`Market config mismatch! Expected base ${tokenBContract.value.trim()} but got ${marketConfig.baseContract}. Prices might be incorrect.`, "error");
                    }
                    logMessage("Market is inverted. Inverting prices for calculation.", "system");
                    // Invert prices to get Price of A in terms of B
                    return data.map(d => ({
                        time: d.time,
                        open: 1 / d.open,
                        high: d.low ? 1 / d.low : 0, // Handle potential division by zero if low is 0
                        low: d.high ? 1 / d.high : 0, // Handle potential division by zero if high is 0
                        close: 1 / d.close,
                        volume: d.volume * d.close // Estimate volume in Token A
                    })).filter(d => d.open && d.high && d.low && d.close); // Filter out any NaN/Infinity/Zero values
                } else {
                     // Ensure the base IS Token A
                    if (marketConfig.baseContract !== tokenAContractInput) {
                        logMessage(`Market config mismatch! Expected base ${tokenAContractInput} but got ${marketConfig.baseContract}. Prices might be incorrect.`, "error");
                    }
                     // Market is NOT inverted (Price of A in terms of B)
                }
                
                // Format data (market is not inverted)
                return data.map(d => ({
                    time: d.time,
                    open: d.open,
                    high: d.high,
                    low: d.low,
                    close: d.close,
                    volume: d.volume
                }));
            } catch (e) {
                logMessage(`Failed to get prices: ${e.message}`, "error");
                marketId = null; // Reset marketId if price fetch fails, to force re-search next time
                marketConfig = { baseContract: null, quoteContract: null };
                return null;
            }
        }

        /**
         * Executes the swap transaction on Alcor
         */
        async function executeSwap(direction) {
            logMessage(`Attempting to execute ${direction.toUpperCase()} swap...`, "system");

            try {
                const config = {
                    aSymbol: tokenASymbol.value.trim().toUpperCase(),
                    aContract: tokenAContract.value.trim(),
                    aDecimals: parseInt(tokenADecimals.value),
                    bSymbol: tokenBSymbol.value.trim().toUpperCase(),
                    bContract: tokenBContract.value.trim(),
                    bDecimals: parseInt(tokenBDecimals.value),
                    dex: dexContract.value.trim(),
                    amountA: parseFloat(tradeAmountA.value),
                    amountB: parseFloat(tradeAmountB.value)
                };

                if (!config.aSymbol || !config.aContract || !config.bSymbol || !config.bContract) {
                    logMessage("Token Symbol and Contract fields must be filled out.", "error");
                    return;
                }
                if (isNaN(config.aDecimals) || isNaN(config.bDecimals)) {
                    logMessage("Token decimals must be valid numbers.", "error");
                    return;
                }
                if (isNaN(config.amountA) || isNaN(config.amountB) || config.amountA <= 0 || config.amountB <= 0) {
                    logMessage("Trade amounts must be valid, positive numbers.", "error");
                    return;
                }

                let actions = [];

                if (direction === 'sell') {
                    // SELLING Token A to get Token B
                    const totalSellAmount = config.amountA;
                    const feeAmount = totalSellAmount * FEE_PERCENT;
                    const userAmount = totalSellAmount - feeAmount;

                    if (userAmount <= 0) {
                        logMessage("Sell amount too small to cover fee.", "error");
                        return;
                    }

                    // 1. User's trade
                    const userQuantity = `${userAmount.toFixed(config.aDecimals)} ${config.aSymbol}`;
                    const minReturnUser = (0).toFixed(config.bDecimals);
                    const memoUser = `swap,${minReturnUser} ${config.bSymbol},${config.bContract}`;
                    
                    actions.push({
                        account: config.aContract,
                        name: 'transfer',
                        authorization: [{ actor: userAccount, permission: 'active' }],
                        data: {
                            from: userAccount,
                            to: config.dex,
                            quantity: userQuantity,
                            memo: memoUser,
                        },
                    });
                    
                    // 2. Fee transfer
                    const feeQuantity = `${feeAmount.toFixed(config.aDecimals)} ${config.aSymbol}`;
                    if (feeAmount > 0) {
                        actions.push({
                            account: config.aContract,
                            name: 'transfer',
                            authorization: [{ actor: userAccount, permission: 'active' }],
                            data: {
                                from: userAccount,
                                to: FEE_RECEIVER,
                                quantity: feeQuantity,
                                memo: `0.1% fee from WAX TA Trader`,
                            },
                        });
                        logMessage(`ACTION (Fee): Transfer ${feeQuantity} to ${FEE_RECEIVER}`, "info");
                    }
                    
                    logMessage(`ACTION (User): Transfer ${userQuantity} to ${config.dex}`, "info");

                } else if (direction === 'buy') {
                    // BUYING Token A by spending Token B
                    const quantity = `${config.amountB.toFixed(config.bDecimals)} ${config.bSymbol}`;
                    const minReturn = (0).toFixed(config.aDecimals);
                    const memo = `swap,${minReturn} ${config.aSymbol},${config.aContract}`;

                    actions.push({
                        account: config.bContract,
                        name: 'transfer',
                        authorization: [{ actor: userAccount, permission: 'active' }],
                        data: {
                            from: userAccount,
                            to: config.dex,
                            quantity: quantity,
                            memo: memo,
                        },
                    });
                    
                    logMessage(`ACTION: Transfer ${quantity} to ${config.dex}`, "info");
                    logMessage(`MEMO: ${memo}`, "info");
                }

                const result = await wax.api.transact({ actions }, {
                    blocksBehind: 3,
                    expireSeconds: 1200,
                });

                logMessage(`Swap successful! TxID: ${result.transaction_id.substring(0, 12)}...`, "success");
                
                // --- Update PnL after successful trade ---
                if (direction === 'buy') {
                    updatePnl('buy', config.amountB);
                } else if (direction === 'sell') {
                    // Estimate received Token B for PnL
                    if (lastPrices.length > 0) {
                        const currentPrice = lastPrices[lastPrices.length - 1].close;
                        const userAmountSold = config.amountA * (1 - FEE_PERCENT);
                        const estimatedReceivedB = userAmountSold * currentPrice;
                        
                        logMessage(`Est. ${estimatedReceivedB.toFixed(config.bDecimals)} ${config.bSymbol} received.`, "info");
                        updatePnl('sell', estimatedReceivedB);
                    } else {
                         logMessage(`Could not estimate PnL for sell trade, no price data available.`, "warn");
                    }
                }

            } catch (e) {
                // Try to parse a more specific error from WAX
                let errorMessage = e.message;
                try {
                    const errorJson = JSON.parse(e.message);
                    if (errorJson.error && errorJson.error.details && errorJson.error.details.length > 0) {
                        errorMessage = errorJson.error.details[0].message;
                    } else if (errorJson.error && errorJson.error.what) {
                        errorMessage = errorJson.error.what;
                    }
                } catch (parseError) {
                    // It wasn't JSON, just use the original message
                }
                logMessage(`Swap failed: ${errorMessage}`, "error");
            }
        }
    </script>
</body>
</html>
