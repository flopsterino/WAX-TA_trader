<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WAX TA Trading Bot</title>
    <script src="waxjs.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/7.12.1/polyfill.min.js"></script>
    <script src="trendyways.min.js"></script>

    <style>
        :root{--bg-primary:#1a1c23;--bg-secondary:#242731;--bg-tertiary:#3a3f4c;--border-color:#4a5160;--text-primary:#e0e2e8;--text-secondary:#a0a6b3;--text-cyan:#22d3ee;--text-green:#34d399;--text-red:#f87171;--text-yellow:#facc15;--text-blue:#60a5fa;--accent-cyan:#06b6d4;--accent-cyan-hover:#0891b2;--accent-green:#10b981;--accent-green-hover:#059669;--accent-red:#ef4444;--accent-red-hover:#dc2626;--accent-blue:#3b82f6;--accent-blue-hover:#2563eb;--shadow-color:rgba(0,0,0,0.2);--font-sans:'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;--font-mono:'Courier New', Courier, monospace;}*{box-sizing:border-box;}body{background-color:var(--bg-primary);color:var(--text-primary);font-family:var(--font-sans);margin:0;padding:1rem;min-height:100vh;}@media (min-width: 768px){body{padding:2rem;}}.container{max-width:800px;margin:0 auto;display:flex;flex-direction:column;gap:1.5rem;}h1{font-size:2.25rem;font-weight:700;text-align:center;margin:0 0 1rem 0;color:var(--text-cyan);}h2{font-size:1.5rem;font-weight:600;margin:0 0 1rem 0;border-bottom:1px solid var(--border-color);padding-bottom:0.5rem;color:var(--text-primary);}.app-section{background-color:var(--bg-secondary);padding:1.5rem;border-radius:8px;box-shadow:0 4px 12px var(--shadow-color);}.alert{padding:1rem;border-radius:6px;border-left:4px solid;}.alert-critical{background-color:#450a0a;border-color:var(--text-red);color:#fecaca;}.alert-critical p{margin:0;}.alert-critical strong{color:white;font-weight:600;}fieldset{border:1px solid var(--border-color);border-radius:6px;padding:1rem 1.5rem;margin-bottom:1rem;}legend{padding:0 0.5rem;font-weight:600;color:var(--text-primary);font-size:1.1rem;}.form-grid{display:grid;grid-template-columns:repeat(1, 1fr);gap:1rem;}@media (min-width: 768px){.form-grid-cols-3{grid-template-columns:repeat(3, 1fr);}.form-grid-cols-2{grid-template-columns:repeat(2, 1fr);}}.form-group{display:flex;flex-direction:column;gap:0.25rem;}label{display:block;font-size:0.875rem;font-weight:500;color:var(--text-secondary);}label .default-text{font-size:0.75rem;color:var(--text-cyan);margin-left:0.25rem;}input[type="text"], input[type="number"], select{background-color:var(--bg-tertiary);border:1px solid var(--border-color);color:var(--text-primary);border-radius:6px;padding:0.75rem 1rem;width:100%;transition:border-color 0.2s, box-shadow 0.2s;font-size:0.9rem;}input[type="text"]:focus, input[type="number"]:focus, select:focus{outline:none;border-color:var(--accent-cyan);box-shadow:0 0 0 3px rgba(6, 182, 212, 0.3);}input:disabled{cursor:not-allowed;opacity:0.6;}.note{font-size:0.75rem;color:var(--text-secondary);margin-top:0.5rem;}button{font-weight:600;padding:0.75rem 1rem;border-radius:6px;cursor:pointer;border:none;transition:background-color 0.2s, opacity 0.2s;width:100%;font-size:1rem;}button.primary{background-color:var(--accent-cyan);color:var(--bg-primary);}button.primary:hover{background-color:var(--accent-cyan-hover);}button.secondary{background-color:var(--bg-tertiary);color:var(--text-primary);width:auto;font-size:0.8rem;font-weight:500;padding:0.25rem 0.75rem;}button.secondary:hover{background-color:var(--border-color);}button.start{background-color:var(--accent-green);color:white;}button.start:hover{background-color:var(--accent-green-hover);}button.stop{background-color:var(--accent-red);color:white;}button.stop:hover{background-color:var(--accent-red-hover);}button:disabled{background-color:var(--bg-tertiary);color:var(--text-secondary);cursor:not-allowed;opacity:0.7;}.button-grid{display:grid;grid-template-columns:1fr 1fr;gap:1rem;margin-bottom:1rem;}.status-grid{margin-top:1rem;display:flex;flex-direction:column;gap:0.75rem;}.status-item{display:flex;justify-content:space-between;align-items:center;}.status-item .label{color:var(--text-secondary);font-size:0.9rem;}.status-item .value{font-weight:700;font-size:1rem;}.status-item .value-group{display:flex;align-items:center;gap:0.5rem;}#user-account{color:var(--text-green);}#pnl-display.positive{color:var(--text-green);}#pnl-display.negative{color:var(--text-red);}#pnl-display.neutral{color:var(--text-secondary);}.bot-status-container{text-align:center;}#bot-status{font-weight:700;font-size:1.1rem;}#bot-status.running{color:var(--text-green);}#bot-status.stopped{color:var(--text-red);}#log-output{font-family:var(--font-mono);max-height:400px;overflow-y:auto;background-color:var(--bg-primary);border:1px solid var(--border-color);padding:1rem;border-radius:6px;font-size:0.875rem;}#log-output p{margin:0 0 0.35rem 0;border-bottom:1px solid var(--bg-tertiary);padding-bottom:0.35rem;word-break:break-all;line-height:1.6;}#log-output p:last-child{border-bottom:none;margin-bottom:0;}#log-output .log-time{color:var(--text-secondary);margin-right:0.5rem;}#log-output .log-info{color:var(--text-primary);}#log-output .log-error{color:var(--text-red);}#log-output .log-success{color:var(--text-green);}#log-output .log-warn{color:var(--text-yellow);}#log-output .log-system{color:var(--text-cyan);}#log-output .log-idle{color:var(--text-secondary);}.strategy-settings.hidden{display:none;}hr{border:none;border-top:1px solid var(--border-color);margin:1.5rem 0;}.modal-overlay{display:none;position:fixed;inset:0;background-color:rgba(0,0,0,0.75);align-items:center;justify-content:center;z-index:50;padding:1rem;}.modal-overlay.visible{display:flex;}.modal-content{background-color:var(--bg-secondary);width:100%;max-width:500px;padding:2rem;border-radius:8px;box-shadow:0 10px 30px var(--shadow-color);position:relative;}.modal-close-btn{position:absolute;top:0.75rem;right:1.25rem;color:var(--text-secondary);font-size:2.5rem;font-weight:300;background:none;border:none;cursor:pointer;padding:0;width:auto;line-height:1;}.modal-close-btn:hover{color:var(--text-primary);}.modal-content h2{text-align:center;color:var(--text-cyan);margin-top:0;margin-bottom:1.5rem;border:none;}.modal-summary{background-color:var(--bg-tertiary);padding:1.5rem;border-radius:6px;margin-bottom:1.5rem;display:flex;flex-direction:column;gap:0.75rem;}.modal-summary-item{display:flex;justify-content:space-between;align-items:center;}.modal-summary-item .label{color:var(--text-secondary);}.modal-summary-item .value{font-weight:600;}#share-wallet{color:var(--text-cyan);}#share-spent{color:var(--text-red);}#share-received{color:var(--text-green);}.modal-summary hr{margin:0.5rem 0;}.modal-summary-total{font-size:1.25rem;font-weight:700;}#share-pnl.positive{color:var(--text-green);}#share-pnl.negative{color:var(--text-red);}#share-pnl.neutral{color:var(--text-secondary);}#copy-share-btn{background-color:var(--accent-cyan);color:var(--bg-primary);}#copy-share-btn:hover{background-color:var(--accent-cyan-hover);}#share-text{position:absolute;left:-9999px;opacity:0;}
    </style>
</head>
<body>
    <div class="container">
        <h1>WAX TA Trading Bot</h1>
        
        <div class="alert alert-critical" role="alert">
            <p><strong>High Risk: Use at Your Own Risk</strong></p>
            <p>This is an educational tool. Automated trading is extremely risky and can lead to a total loss of funds. You are solely responsible for your actions. A 0.1% fee on all sell trades is sent to `qu.ug.wam`.</p>
        </div>

        <div class="app-section">
            <h2>Step 1: Connect & Status</h2>
            <button id="login-btn" class="primary"> Login with WAX Wallet </button>
            <div class="status-grid">
                <div class="status-item">
                    <span class="label">Wallet:</span> 
                    <strong id="user-account" class="value">Not Logged In</strong>
                </div>
                <div class="status-item">
                    <span class="label">Your PnL:</span>
                    <div class="value-group">
                        <span id="pnl-display" class="value neutral">0.00</span>
                        <button id="share-pnl-btn" class="secondary">Share</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="app-section">
            <h2>Step 2: Configure Tokens</h2>
            <div class="form-grid form-grid-cols-2">
                <div class="form-group">
                    <label for="select-token-a">Token A (The token you want to trade)</label>
                    <select id="select-token-a">
                        </select>
                </div>
                <div class="form-group">
                    <label for="select-token-b">Token B (The token you spend/receive, e.g., WAX)</label>
                    <select id="select-token-b">
                        </select>
                </div>
            </div>
            <button id="add-token-btn" class="primary" style="margin-top: 1rem;">Add New Token</button>
        </div>
        <div class="app-section">
            <h2>Step 3: Define Strategy</h2>
            <div class="form-grid form-grid-cols-2">
                <div class="form-group">
                    <label for="strategy-select">Trading Strategy</label>
                    <select id="strategy-select">
                        <option value="rsi">RSI Strategy (Default)</option>
                        <option value="price-range">Price Range Strategy</option>
                        <option value="short-term">Short Term Trading (1-min)</option> 
                        <option value="range-trading">Range Trading</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="timeframe-select">Chart Timeframe</label>
                    <select id="timeframe-select">
                        <option value="1">1 Minute (Required for Short Term)</option>
                        <option value="5">5 Minutes</option>
                        <option value="15">15 Minutes</option>
                        <option value="30">30 Minutes</option>
                        <option value="60" selected>1 Hour</option>
                        <option value="240">4 Hours</option>
                        <option value="1440">1 Day</option>
                    </select>
                </div>
            </div>

            <div id="rsi-settings" class="strategy-settings form-grid form-grid-cols-2" style="margin-top: 1rem;">
                <div class="form-group">
                    <label for="rsi-buy"> Buy Token A when 14-period RSI is below: <span class="default-text">(Default: 30)</span> </label>
                    <input type="number" id="rsi-buy" value="30">
                </div>
                <div class="form-group">
                    <label for="rsi-sell"> Sell Token A when 14-period RSI is above: <span class="default-text">(Default: 70)</span> </label>
                    <input type="number" id="rsi-sell" value="70">
                </div>
            </div>
            
            <div id="price-range-settings" class="strategy-settings hidden form-grid form-grid-cols-2" style="margin-top: 1rem;">
                 <p class="note" style="margin-top:0; margin-bottom: 0.5rem; grid-column: 1 / -1;">Simple one-way buy low or sell high based on RSI.</p>
                <div class="form-group">
                    <label for="price-lower"> Lower Buy Price (in Token B) </label>
                    <input type="number" id="price-lower" placeholder="e.g., 0.05">
                </div>
                <div class="form-group">
                    <label for="price-upper"> Upper Sell Price (in Token B) </label>
                    <input type="number" id="price-upper" placeholder="e.g., 0.10">
                </div>
            </div>

            <div id="short-term-settings" class="strategy-settings hidden" style="margin-top: 1rem;">
                <fieldset>
                    <legend>Short Term Strategy (1-Minute)</legend>
                    <div class="form-grid form-grid-cols-2">
                        <div class="form-group">
                             <label for="short-term-strategy-select">Select 1-min Strategy</label>
                             <select id="short-term-strategy-select">
                                <option value="volume-spike">Volume Spike (Majority Rules)</option>
                                <option value="ema-crossover">EMA Crossover</option>
                             </select>
                        </div>
                         <div class="form-group">
                            <label for="short-term-tf-warning" style="color: var(--text-yellow);">Timeframe Warning</label>
                            <input type="text" id="short-term-tf-warning" value="Set Timeframe to 1-Min" disabled style="color: var(--text-yellow); border-color: var(--text-yellow);">
                        </div>
                    </div>
                </fieldset>

                <div id="volume-spike-settings" class="strategy-settings hidden">
                    <fieldset style="margin-top: 1rem; border-color: var(--accent-cyan);">
                        <legend style="color: var(--accent-cyan);">Volume Spike (Majority Rules) Settings</legend>
                        <p class="note" style="margin-top:0; margin-bottom: 1rem;">Buys if 2-of-3 signals are true (Trend, Volume, Price Action). Sells on Take Profit / Stop Loss.</p>
                        <div class="form-grid form-grid-cols-3">
                             <div class="form-group">
                                <label for="vol-multiplier">Volume Multiplier <span class="default-text">(e.g., 5)</span></label>
                                <input type="number" id="vol-multiplier" value="5">
                            </div>
                            <div class="form-group">
                                <label for="vol-avg-candles">Avg. Volume Candles <span class="default-text">(e.g., 20)</span></label>
                                <input type="number" id="vol-avg-candles" value="20">
                            </div>
                             <div class="form-group">
                                <label for="vol-trend-ema">Trend EMA Period <span class="default-text">(0=off)</span></label>
                                <input type="number" id="vol-trend-ema" value="50">
                            </div>
                        </div>
                        <div class="form-grid form-grid-cols-2" style="margin-top: 1rem;">
                            <div class="form-group">
                                <label for="vol-take-profit">Take Profit % <span class="default-text">(e.g., 3)</span></label>
                                <input type="number" id="vol-take-profit" value="3">
                            </div>
                            <div class="form-group">
                                <label for="vol-stop-loss">Stop Loss % <span class="default-text">(e.g., 2)</span></label>
                                <input type="number" id="vol-stop-loss" value="2">
                            </div>
                        </div>
                    </fieldset>
                </div>

                <div id="ema-crossover-settings" class="strategy-settings hidden">
                     <fieldset style="margin-top: 1rem; border-color: var(--accent-green);">
                        <legend style="color: var(--accent-green);">EMA Crossover Settings</legend>
                        <p class="note" style="margin-top:0; margin-bottom: 1rem;">Buys when the Fast EMA crosses *above* the Slow EMA. Sells when it crosses *below*.</p>
                        <div class="form-grid form-grid-cols-2">
                             <div class="form-group">
                                <label for="ema-fast">Fast EMA Period <span class="default-text">(e.g., 9)</span></label>
                                <input type="number" id="ema-fast" value="9">
                            </div>
                            <div class="form-group">
                                <label for="ema-slow">Slow EMA Period <span class="default-text">(e.g., 21)</span></label>
                                <input type="number" id="ema-slow" value="21">
                            </div>
                        </div>
                    </fieldset>
                </div>

            </div>
            
            <div id="range-trading-settings" class="strategy-settings hidden" style="margin-top: 1rem;">
                <fieldset>
                    <legend>Range Trading Settings</legend>
                     <p class="note" style="margin-top:0; margin-bottom: 1rem;">Buys at the Lower Bound, Sells at the Upper Bound. Requires current price to be within range on start.</p>
                    <div class="form-grid form-grid-cols-2">
                         <div class="form-group">
                            <label for="range-lower"> Lower Buy Price (in Token B) </label>
                            <input type="number" id="range-lower" placeholder="e.g., 1.05">
                        </div>
                        <div class="form-group">
                            <label for="range-upper"> Upper Sell Price (in Token B) </label>
                            <input type="number" id="range-upper" placeholder="e.g., 1.15">
                        </div>
                    </div>
                     <div class="form-grid form-grid-cols-2" style="margin-top: 1rem;">
                         <div class="form-group">
                            <label for="range-current-price">Current Price (for reference)</label>
                            <input type="text" id="range-current-price" value="Fetching..." disabled>
                        </div>
                        <div class="form-group">
                             <label for="range-status">Range Status</label>
                            <input type="text" id="range-status" value="Enter bounds" disabled>
                        </div>
                     </div>
                </fieldset>
            </div>


            <hr>
            <div class="form-grid form-grid-cols-2">
                <div class="form-group">
                    <label for="trade-amount-a">Amount of Token A to SELL:</label>
                    <input type="number" id="trade-amount-a" value="100">
                </div>
                <div class="form-group">
                    <label for="trade-amount-b">Amount of Token B to spend on BUY:</label>
                    <input type="number" id="trade-amount-b" value="10">
                </div>
            </div>
            <div class="form-group" style="margin-top: 1rem;">
                <label for="dex-contract">DEX Router Contract (Alcor is default)</label>
                <input type="text" id="dex-contract" value="alcor.swap">
                <p class="note"> Note: The <code>alcor.swap</code> router automatically uses both Liquidity Pools (LPs) and the spot market to find the best trade price. </p>
            </div>
        </div>

         <div class="app-section">
            <h2>Step 3.5: Budget Control (Optional)</h2>
             <p class="note" style="margin-top:0; margin-bottom: 1rem;">Set initial budget amounts for each token. The bot will stop automatically if it tries to spend more than this initial amount for *either* token (ignores profits/losses). Leave at 0 to disable budget control.</p>
            <fieldset>
                <legend>Initial Budget Limits</legend>
                 <div class="form-grid form-grid-cols-2">
                    <div class="form-group">
                        <label for="budget-token-a">Max Initial Token A to Spend</label>
                        <input type="number" id="budget-token-a" value="0">
                         <span class="note" id="budget-a-spent-display">Spent: 0 / 0</span>
                    </div>
                    <div class="form-group">
                        <label for="budget-token-b">Max Initial Token B to Spend</label>
                        <input type="number" id="budget-token-b" value="0">
                        <span class="note" id="budget-b-spent-display">Spent: 0 / 0</span>
                    </div>
                </div>
            </fieldset>
         </div>
         <div class="app-section">
            <h2>Step 4: Control Panel</h2>
            <div class="button-grid">
                <button id="start-btn" class="start"> Start Bot </button>
                <button id="stop-btn" class="stop" disabled> Stop Bot </button>
            </div>
            <div class="bot-status-container">
                <span style="color: var(--text-secondary);">Status:</span> 
                <strong id="bot-status" class="stopped">STOPPED</strong>
            </div>
        </div>

        <div class="app-section">
            <h2>Bot Log</h2>
            <div id="log-output">
                <p class="log-idle">Bot is idle. Please log in, configure settings, and press Start.</p>
            </div>
        </div>
    </div> 

    <div id="share-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="close-share-modal-btn" class="modal-close-btn">&times;</button>
            <h2>My Trading Bot PnL</h2>
            <div class="modal-summary">
                <div class="modal-summary-item"><span class="label">Wallet:</span><span id="share-wallet" class="value">...</span></div>
                <div class="modal-summary-item"><span class="label">Total Spent (B):</span><span id="share-spent" class="value">0.00</span></div>
                <div class="modal-summary-item"><span class="label">Total Received (B):</span><span id="share-received" class="value">0.00</span></div>
                <hr>
                <div class="modal-summary-item modal-summary-total"><span class="label">Net PnL:</span><span id="share-pnl" class="value neutral">0.00</span></div>
            </div>
            <textarea id="share-text"></textarea> 
            <button id="copy-share-btn"> Copy Sharable Text </button>
        </div>
    </div>

    <div id="add-token-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="close-add-token-modal-btn" class="modal-close-btn">&times;</button>
            <h2>Add New Token</h2>
            <div class="form-grid" style="gap: 1.5rem;">
                 <div class="form-group">
                    <label for="modal-token-symbol">Symbol (e.g., TLM)</label>
                    <input type="text" id="modal-token-symbol" placeholder="TLM">
                </div>
                <div class="form-group">
                    <label for="modal-token-contract">Contract (e.g., alien.worlds)</label>
                    <input type="text" id="modal-token-contract" placeholder="alien.worlds">
                </div>
                <div class="form-group">
                    <label for="modal-token-decimals">Decimals (e.g., 4)</label>
                    <input type="number" id="modal-token-decimals" placeholder="4">
                </div>
            </div>
            <button id="save-token-btn" class="primary" style="margin-top: 1.5rem;">Save Token</button>
        </div>
    </div>
    <script>
        // --- Global Variables ---
        let wax;
        let userAccount = null;
        let botInterval = null;
        let isBotRunning = false;
        let lastPrices = []; 
        let pnlData = { totalSpentTokenB: 0, totalReceivedTokenB: 0, pnl: 0 };
        let botState = { inPosition: false, buyPrice: 0.0, strategy: null };
        // [ --- NEW: Budget State --- ]
        let budgetState = { initialA: 0.0, initialB: 0.0, spentA: 0.0, spentB: 0.0, enabled: false };
        let currentMarket = { id: null, type: null }; 
        let marketConfig = { baseContract: null, quoteContract: null, isInverted: false };
        let tw = null; 
        
        let tokenList = [];
        const DEFAULT_TOKENS = [
            { symbol: "WAX", contract: "eosio.token", decimals: 8 },
            { symbol: "TLM", contract: "alien.worlds", decimals: 4 },
            { symbol: "AETHER", contract: "aether.rplanet", decimals: 4 }
        ];

        const WAX_RPC_ENDPOINT = 'https://wax.greymass.com';
        const FEE_RECEIVER = 'qu.ug.wam';
        const FEE_PERCENT = 0.001; 
        const ALCOR_API = 'https://wax.alcor.exchange/api/v2';

        // --- DOM Elements ---
        let loginBtn, userAccountDisplay, startBtn, stopBtn, botStatusDisplay, logOutput, pnlDisplay;
        let shareModal, sharePnlBtn, closeShareModalBtn, shareWallet, shareSpent, shareReceived, sharePnl, copyShareBtn, shareText;
        
        let selectTokenA, selectTokenB, addTokenBtn;
        let addTokenModal, closeAddTokenModalBtn, saveTokenBtn, modalTokenSymbol, modalTokenContract, modalTokenDecimals;
        
        let timeframeSelect, dexContract, tradeAmountA, tradeAmountB;
        let strategySelect, rsiSettings, priceRangeSettings, rsiBuy, rsiSell, priceLower, priceUpper;
        
        let shortTermSettings, shortTermStrategySelect, shortTermTfWarning;
        let volumeSpikeSettings, volMultiplier, volAvgCandles, volTakeProfit, volStopLoss, volTrendEma;
        let emaCrossoverSettings, emaFast, emaSlow;
        
        let rangeTradingSettings, rangeLower, rangeUpper, rangeCurrentPrice, rangeStatus;

        // [ --- NEW: Budget DOM Elements --- ]
        let budgetTokenA, budgetTokenB, budgetASpentDisplay, budgetBSpentDisplay;


        // --- Assign DOM Elements ---
        function assignDomElements() {
            loginBtn = document.getElementById('login-btn'); 
            userAccountDisplay = document.getElementById('user-account'); 
            startBtn = document.getElementById('start-btn'); 
            stopBtn = document.getElementById('stop-btn'); 
            botStatusDisplay = document.getElementById('bot-status'); 
            logOutput = document.getElementById('log-output'); 
            pnlDisplay = document.getElementById('pnl-display'); 
            shareModal = document.getElementById('share-modal'); 
            sharePnlBtn = document.getElementById('share-pnl-btn'); 
            closeShareModalBtn = document.getElementById('close-share-modal-btn'); 
            shareWallet = document.getElementById('share-wallet'); 
            shareSpent = document.getElementById('share-spent'); 
            shareReceived = document.getElementById('share-received'); 
            sharePnl = document.getElementById('share-pnl'); 
            copyShareBtn = document.getElementById('copy-share-btn'); 
            shareText = document.getElementById('share-text'); 
            
            selectTokenA = document.getElementById('select-token-a');
            selectTokenB = document.getElementById('select-token-b');
            addTokenBtn = document.getElementById('add-token-btn');
            addTokenModal = document.getElementById('add-token-modal');
            closeAddTokenModalBtn = document.getElementById('close-add-token-modal-btn');
            saveTokenBtn = document.getElementById('save-token-btn');
            modalTokenSymbol = document.getElementById('modal-token-symbol');
            modalTokenContract = document.getElementById('modal-token-contract');
            modalTokenDecimals = document.getElementById('modal-token-decimals');

            timeframeSelect = document.getElementById('timeframe-select'); 
            dexContract = document.getElementById('dex-contract'); 
            tradeAmountA = document.getElementById('trade-amount-a'); 
            tradeAmountB = document.getElementById('trade-amount-b'); 
            strategySelect = document.getElementById('strategy-select'); 
            rsiSettings = document.getElementById('rsi-settings'); 
            priceRangeSettings = document.getElementById('price-range-settings'); 
            rsiBuy = document.getElementById('rsi-buy'); 
            rsiSell = document.getElementById('rsi-sell'); 
            priceLower = document.getElementById('price-lower'); 
            priceUpper = document.getElementById('price-upper');

            shortTermSettings = document.getElementById('short-term-settings');
            shortTermStrategySelect = document.getElementById('short-term-strategy-select');
            shortTermTfWarning = document.getElementById('short-term-tf-warning');
            
            volumeSpikeSettings = document.getElementById('volume-spike-settings');
            volMultiplier = document.getElementById('vol-multiplier');
            volAvgCandles = document.getElementById('vol-avg-candles');
            volTakeProfit = document.getElementById('vol-take-profit');
            volStopLoss = document.getElementById('vol-stop-loss');
            volTrendEma = document.getElementById('vol-trend-ema'); 

            emaCrossoverSettings = document.getElementById('ema-crossover-settings');
            emaFast = document.getElementById('ema-fast');
            emaSlow = document.getElementById('ema-slow');

            rangeTradingSettings = document.getElementById('range-trading-settings');
            rangeLower = document.getElementById('range-lower');
            rangeUpper = document.getElementById('range-upper');
            rangeCurrentPrice = document.getElementById('range-current-price');
            rangeStatus = document.getElementById('range-status');

             // [ --- NEW: Assign Budget DOM Elements --- ]
            budgetTokenA = document.getElementById('budget-token-a');
            budgetTokenB = document.getElementById('budget-token-b');
            budgetASpentDisplay = document.getElementById('budget-a-spent-display');
            budgetBSpentDisplay = document.getElementById('budget-b-spent-display');
        }

        // --- PnL Functions ---
        function loadPnlFromStorage() { const savedData = localStorage.getItem('waxTraderPnl'); if (savedData) { pnlData = JSON.parse(savedData); logMessage("Loaded PnL data from storage.", "system"); } else { logMessage("No PnL data found, starting fresh.", "system"); } updatePnlDisplay(); }
        function savePnlToStorage() { localStorage.setItem('waxTraderPnl', JSON.stringify(pnlData)); }
        function updatePnl(direction, amountB) { if (direction === 'buy') { pnlData.totalSpentTokenB += amountB; } else if (direction === 'sell') { pnlData.totalReceivedTokenB += amountB; } pnlData.pnl = pnlData.totalReceivedTokenB - pnlData.totalSpentTokenB; savePnlToStorage(); updatePnlDisplay(); logMessage(`PnL updated: ${pnlData.pnl.toFixed(4)}`, "success"); }
        
        function updatePnlDisplay() {
            const pnlValue = pnlData.pnl || 0;
            const tokenB = getSelectedTokenConfig('select-token-b');
            const tokenSymbol = tokenB ? tokenB.symbol.toUpperCase() : 'Token B'; 
            
            pnlDisplay.textContent = `${pnlValue.toFixed(4)} ${tokenSymbol}`;
            pnlDisplay.className = pnlValue > 0 ? "value positive" : pnlValue < 0 ? "value negative" : "value neutral";
        }

        // --- Share Modal Functions ---
        function openShareModal() {
            const tokenB = getSelectedTokenConfig('select-token-b');
            const tokenSymbol = tokenB ? tokenB.symbol.toUpperCase() : 'Token B';
            const pnlValue = pnlData.pnl || 0; 
            
            shareWallet.textContent = userAccount || 'N/A'; 
            shareSpent.textContent = `${pnlData.totalSpentTokenB.toFixed(4)} ${tokenSymbol}`; 
            shareReceived.textContent = `${pnlData.totalReceivedTokenB.toFixed(4)} ${tokenSymbol}`; 
            sharePnl.textContent = `${pnlValue.toFixed(4)} ${tokenSymbol}`; 
            sharePnl.className = pnlValue > 0 ? "value positive" : pnlValue < 0 ? "value negative" : "value neutral"; 
            
            const textToCopy = `📈 My WAX TA Bot Report 📈\n-------------------------\nWallet: ${userAccount}\nNet PnL: ${pnlValue.toFixed(4)} ${tokenSymbol}\n(Spent: ${pnlData.totalSpentTokenB.toFixed(4)} | Received: ${pnlData.totalReceivedTokenB.toFixed(4)})\n-------------------------\nBot by: qu.ug.wam`; 
            shareText.value = textToCopy.trim(); 
            shareModal.classList.add('visible'); 
        }
        function closeShareModal() { shareModal.classList.remove('visible'); }
        function copyShareText() { shareText.select(); shareText.setSelectionRange(0, 99999); try { document.execCommand('copy'); copyShareBtn.textContent = 'Copied!'; setTimeout(() => { copyShareBtn.textContent = 'Copy Sharable Text'; }, 2000); } catch (err) { logMessage('Failed to copy share text.', 'error'); } }


        // --- Bot State Management (with strategy) ---
        function loadBotState() {
            const savedData = localStorage.getItem('waxTraderBotState');
            if (savedData) {
                botState = JSON.parse(savedData);
                botState.inPosition = botState.inPosition || false;
                botState.buyPrice = botState.buyPrice || 0.0;
                botState.strategy = botState.strategy || null;
                if(botState.inPosition) { logMessage(`Loaded bot state: IN POSITION (via ${botState.strategy || 'unknown'}). Bought at ${botState.buyPrice}. Looking for sell...`, "warn"); } else { logMessage("Loaded bot state: Not in position.", "system"); }
            } else {
                botState = { inPosition: false, buyPrice: 0.0, strategy: null };
                logMessage("No bot state found, starting fresh.", "system");
            }
        }
        function saveBotState() { localStorage.setItem('waxTraderBotState', JSON.stringify(botState)); }


        // [ --- NEW: Budget State Management --- ]
        function loadBudgetState() {
            const savedData = localStorage.getItem('waxTraderBudgetState');
             if (savedData) {
                budgetState = JSON.parse(savedData);
                 // Ensure defaults exist if loaded state is old
                budgetState.initialA = budgetState.initialA || 0.0;
                budgetState.initialB = budgetState.initialB || 0.0;
                budgetState.spentA = budgetState.spentA || 0.0;
                budgetState.spentB = budgetState.spentB || 0.0;
                budgetState.enabled = (budgetState.initialA > 0 || budgetState.initialB > 0);
                
                logMessage(`Loaded budget state. Enabled: ${budgetState.enabled}`, "system");
             } else {
                 // Initialize fresh state but don't save yet (wait for startBot)
                 budgetState = { initialA: 0.0, initialB: 0.0, spentA: 0.0, spentB: 0.0, enabled: false };
                 logMessage("No budget state found.", "system");
             }
             updateBudgetDisplay(); // Update UI with loaded or default values
        }
        function saveBudgetState() { localStorage.setItem('waxTraderBudgetState', JSON.stringify(budgetState)); }

        function updateBudgetDisplay() {
            const tokenA = getSelectedTokenConfig('select-token-a');
            const tokenB = getSelectedTokenConfig('select-token-b');
            const symbolA = tokenA ? tokenA.symbol.toUpperCase() : 'A';
            const symbolB = tokenB ? tokenB.symbol.toUpperCase() : 'B';
            
            budgetASpentDisplay.textContent = `Spent: ${budgetState.spentA.toFixed(4)} / ${budgetState.initialA.toFixed(4)} ${symbolA}`;
            budgetBSpentDisplay.textContent = `Spent: ${budgetState.spentB.toFixed(4)} / ${budgetState.initialB.toFixed(4)} ${symbolB}`;
            
            // Optionally update input fields if needed (e.g., if loaded from storage)
             // budgetTokenA.value = budgetState.initialA;
             // budgetTokenB.value = budgetState.initialB;
        }

        // --- Core Functions ---
        function logMessage(message, level = "info") { if (!logOutput) { console.log(`[${level.toUpperCase()}] ${message}`); return; } const p = document.createElement('p'); const timestamp = new Date().toLocaleTimeString(); let levelClass = "log-info"; if (level === "error") levelClass = "log-error"; if (level === "success") levelClass = "log-success"; if (level === "warn") levelClass = "log-warn"; if (level === "system") levelClass = "log-system"; p.className = levelClass; p.innerHTML = `<span class="log-time">[${timestamp}]</span> ${message}`; const placeholder = logOutput.querySelector('.log-idle'); if (placeholder) placeholder.remove(); logOutput.prepend(p); }
        
        // [ --- MODIFIED: `toggleStrategySettings` for new strategy --- ]
        function toggleStrategySettings() { 
            const selectedStrategy = strategySelect.value; 
            
            // Toggle main panels
            rsiSettings.classList.toggle('hidden', selectedStrategy !== 'rsi'); 
            priceRangeSettings.classList.toggle('hidden', selectedStrategy !== 'price-range'); 
            shortTermSettings.classList.toggle('hidden', selectedStrategy !== 'short-term');
            rangeTradingSettings.classList.toggle('hidden', selectedStrategy !== 'range-trading'); 
            
            // Toggle sub-panels if short-term is selected
            if(selectedStrategy === 'short-term') {
                const subStrategy = shortTermStrategySelect.value;
                volumeSpikeSettings.classList.toggle('hidden', subStrategy !== 'volume-spike');
                emaCrossoverSettings.classList.toggle('hidden', subStrategy !== 'ema-crossover');
                
                // Show warning if 1-min timeframe isn't selected
                if(timeframeSelect.value !== '1') {
                    shortTermTfWarning.style.display = 'block';
                } else {
                    shortTermTfWarning.style.display = 'none';
                }
            } 
            else if (selectedStrategy === 'range-trading') {
                updateRangeStatus(); 
            }
        }

        // [ --- MODIFIED: Function to update Range Trading status display --- ]
        async function updateRangeStatus() {
            const lower = parseFloat(rangeLower.value);
            const upper = parseFloat(rangeUpper.value);
            
             if (isNaN(lower) || isNaN(upper) || lower <= 0 || upper <= 0 || lower >= upper) {
                rangeCurrentPrice.value = 'Invalid bounds';
                rangeStatus.value = 'Set valid bounds';
                rangeStatus.style.color = 'var(--text-yellow)';
                 rangeStatus.style.borderColor = 'var(--text-yellow)';
                return;
            }

            // --- Find market if needed ---
            let marketFound = (currentMarket.id && currentMarket.type);
            if (!marketFound) {
                 logMessage("Range Status: Finding market to check price...", "system");
                 const marketInfo = await findMarketId(); 
                 if (marketInfo) { 
                     currentMarket = marketInfo; // Store temporarily for price check
                     marketFound = true;
                     logMessage("Range Status: Market found.", "system");
                 } else {
                     logMessage("Range Status: Could not find market.", "warn");
                 }
            }
             
             if (!marketFound) {
                 rangeCurrentPrice.value = 'Market N/A';
                 rangeStatus.value = 'Cannot get price';
                 rangeStatus.style.color = 'var(--text-yellow)';
                 rangeStatus.style.borderColor = 'var(--text-yellow)';
                 return; 
             }
            // --- End find market ---
            
            const priceData = await getCurrentPrice(currentMarket.id, currentMarket.type);
            if (!priceData) {
                 rangeCurrentPrice.value = 'API Error';
                 rangeStatus.value = 'Cannot get price';
                  rangeStatus.style.color = 'var(--text-red)';
                  rangeStatus.style.borderColor = 'var(--text-red)';
                 // Reset temporary market find if bot isn't running
                 if (!isBotRunning) currentMarket = { id: null, type: null }; 
                 return;
            }
            
            const price = priceData.price;
            const tokenB = getSelectedTokenConfig('select-token-b');
            const symbolB = tokenB ? tokenB.symbol.toUpperCase() : 'B';
            rangeCurrentPrice.value = `${price.toFixed(6)} ${symbolB}`;

            if (price >= lower && price <= upper) {
                rangeStatus.value = '✅ Price is IN range';
                 rangeStatus.style.color = 'var(--text-green)';
                 rangeStatus.style.borderColor = 'var(--text-green)';
            } else if (price < lower) {
                 rangeStatus.value = '❌ Price BELOW range';
                 rangeStatus.style.color = 'var(--text-red)';
                 rangeStatus.style.borderColor = 'var(--text-red)';
            } else { // price > upper
                 rangeStatus.value = '❌ Price ABOVE range';
                 rangeStatus.style.color = 'var(--text-red)';
                 rangeStatus.style.borderColor = 'var(--text-red)';
            }
            // Reset temporary market find if bot isn't running
            if (!isBotRunning) currentMarket = { id: null, type: null };
        }

        // --- Initialization ---
        window.addEventListener('load', () => { assignDomElements(); logMessage("Page loaded. Waiting for required libraries...", "system"); waitForLibraries(); });
        function waitForLibraries() { let interval = setInterval(() => { if (typeof waxjs !== 'undefined' && typeof window.tw !== 'undefined') { clearInterval(interval); logMessage("Libraries loaded successfully.", "success"); initializeApp(); } }, 100); setTimeout(() => { clearInterval(interval); if (typeof waxjs === 'undefined' || typeof window.tw === 'undefined') { let errorMsg = "FATAL: Libraries failed to load after 10 seconds. "; if (typeof waxjs === 'undefined') errorMsg += "waxjs failed. "; if (typeof window.tw === 'undefined') errorMsg += "trendyways (tw) failed. "; logMessage(errorMsg + "Check script tags and file locations.", "error"); } }, 10000); }
        
        function initializeApp() {
            tw = window.tw; 
            wax = new waxjs.WaxJS({ rpcEndpoint: WAX_RPC_ENDPOINT, tryAutoLogin: false }); 
            
            loadPnlFromStorage();
            loadTokenList();
            loadBotState(); 
            loadBudgetState(); // [ --- NEW: Load budget state --- ]
            
            loginBtn.addEventListener('click', login); 
            startBtn.addEventListener('click', startBot); 
            stopBtn.addEventListener('click', stopBot); 
            sharePnlBtn.addEventListener('click', openShareModal); 
            closeShareModalBtn.addEventListener('click', closeShareModal); 
            copyShareBtn.addEventListener('click', copyShareText); 
            strategySelect.addEventListener('change', toggleStrategySettings); 
            timeframeSelect.addEventListener('change', toggleStrategySettings);
            shareModal.addEventListener('click', (e) => { if (e.target === shareModal) closeShareModal(); }); 

            addTokenBtn.addEventListener('click', openAddTokenModal);
            closeAddTokenModalBtn.addEventListener('click', closeAddTokenModal);
            saveTokenBtn.addEventListener('click', saveNewToken); 
            addTokenModal.addEventListener('click', (e) => { if (e.target === addTokenModal) closeAddTokenModal(); });

            selectTokenA.addEventListener('change', () => { updatePnlDisplay(); updateBudgetDisplay(); updateRangeStatus(); }); // Update budget display too
            selectTokenB.addEventListener('change', () => { updatePnlDisplay(); updateBudgetDisplay(); updateRangeStatus(); }); // Update budget display too

            shortTermStrategySelect.addEventListener('change', toggleStrategySettings);

            rangeLower.addEventListener('input', updateRangeStatus);
            rangeUpper.addEventListener('input', updateRangeStatus);

            logMessage("App initialized. Please log in.", "system");
            toggleStrategySettings(); 
        }

        // --- Login ---
        async function login() { try { logMessage("Attempting login...", "system"); userAccount = await wax.login(); userAccountDisplay.textContent = userAccount; loginBtn.disabled = true; loginBtn.textContent = "Logged In"; logMessage(`Logged in as: ${userAccount}`, "success"); } catch (e) { logMessage(`Login failed: ${e.message}`, "error"); } }


        // --- Token Management Functions ---
        // ... (loadTokenList, saveTokenList, populateTokenDropdowns, open/closeAddTokenModal, saveNewToken, getSelectedTokenConfig - unchanged) ...
        function loadTokenList() {
            const savedTokens = localStorage.getItem('waxTraderTokens');
            if (savedTokens) {
                try {
                    tokenList = JSON.parse(savedTokens);
                    if (!Array.isArray(tokenList)) { 
                         tokenList = [...DEFAULT_TOKENS];
                         logMessage("Token list in storage was corrupted. Loading defaults.", "warn");
                         saveTokenList();
                    } else {
                        logMessage("Loaded token list from storage.", "system");
                    }
                } catch(e) {
                     tokenList = [...DEFAULT_TOKENS];
                     logMessage("Failed to parse token list. Loading defaults.", "warn");
                     saveTokenList();
                }
            } else {
                tokenList = [...DEFAULT_TOKENS];
                logMessage("No token list found, loading defaults.", "system");
                saveTokenList();
            }
            populateTokenDropdowns();
        }
        function saveTokenList() { localStorage.setItem('waxTraderTokens', JSON.stringify(tokenList)); }
        function populateTokenDropdowns() {
            const currentA = selectTokenA.value;
            const currentB = selectTokenB.value;
            selectTokenA.innerHTML = '';
            selectTokenB.innerHTML = '';
            if (tokenList.length === 0) { const option = "<option value='-1'>Please add a token...</option>"; selectTokenA.innerHTML = option; selectTokenB.innerHTML = option; return; }
            tokenList.forEach((token, index) => { if (token && token.symbol && token.contract) { const optionHTML = `<option value="${index}">${token.symbol.toUpperCase()} (${token.contract})</option>`; selectTokenA.insertAdjacentHTML('beforeend', optionHTML); selectTokenB.insertAdjacentHTML('beforeend', optionHTML); } });
            selectTokenA.value = (currentA && tokenList[currentA]) ? currentA : "1"; 
            selectTokenB.value = (currentB && tokenList[currentB])? currentB : "0"; 
             if (tokenList.length > 1) { if (selectTokenA.value === "") selectTokenA.value = "1"; if (selectTokenB.value === "") selectTokenB.value = "0"; } else if (tokenList.length === 1) { if (selectTokenA.value === "") selectTokenA.value = "0"; if (selectTokenB.value === "") selectTokenB.value = "0"; }
            updatePnlDisplay(); 
            updateBudgetDisplay(); // Also update budget display when tokens change
        }
        function openAddTokenModal() { modalTokenSymbol.value = ''; modalTokenContract.value = ''; modalTokenDecimals.value = ''; addTokenModal.classList.add('visible'); }
        function closeAddTokenModal() { addTokenModal.classList.remove('visible'); }
        async function saveNewToken() {
            const symbol = modalTokenSymbol.value.trim().toUpperCase();
            const contract = modalTokenContract.value.trim().toLowerCase();
            let decimals = parseInt(modalTokenDecimals.value); 
            if (!symbol || !contract || isNaN(decimals) || decimals < 0) { logMessage("Invalid token details. Please fill all fields correctly.", "error"); return; }
            const isDuplicate = tokenList.some(token => token.symbol === symbol && token.contract === contract);
            if (isDuplicate) { logMessage(`Token ${symbol}@${contract} is already in your list.`, "warn"); return; }
            const tokenId = `${symbol.toLowerCase()}-${contract}`;
            const verificationUrl = `${ALCOR_API}/tokens/${tokenId}`;
            logMessage(`Verifying token ${symbol}@${contract} with Alcor API...`, "system");
            saveTokenBtn.disabled = true; 
            saveTokenBtn.textContent = 'Verifying...';
            try {
                const response = await fetch(verificationUrl);
                if (response.ok) {
                    const tokenData = await response.json();
                    const verifiedSymbol = tokenData.symbol;
                    const verifiedContract = tokenData.contract;
                    const verifiedDecimals = parseInt(tokenData.decimals);
                    logMessage(`Verification successful: ${verifiedSymbol}@${verifiedContract}.`, "success");
                     const isVerifiedDuplicate = tokenList.some(token => token.symbol === verifiedSymbol && token.contract === verifiedContract);
                    if (isVerifiedDuplicate) { logMessage(`Token ${verifiedSymbol}@${verifiedContract} is already in your list.`, "warn"); closeAddTokenModal(); return; }
                    tokenList.push({ symbol: verifiedSymbol, contract: verifiedContract, decimals: isNaN(verifiedDecimals) ? decimals : verifiedDecimals });
                    saveTokenList();
                    populateTokenDropdowns();
                    logMessage(`Added new token: ${verifiedSymbol}@${verifiedContract}`, "success");
                    closeAddTokenModal();
                } else if (response.status === 404) {
                    logMessage(`Verification failed: Token ${symbol}@${contract} not found on Alcor.`, "error");
                } else {
                    logMessage(`Verification failed: API returned status ${response.status} for ${symbol}@${contract}.`, "error");
                }
            } catch (e) {
                logMessage(`Error during token verification: ${e.message}`, "error");
            } finally {
                saveTokenBtn.disabled = false;
                saveTokenBtn.textContent = 'Save Token';
            }
        }
        function getSelectedTokenConfig(elementId) { const selectEl = document.getElementById(elementId); if (!selectEl) return null; const selectedIndex = parseInt(selectEl.value); if (isNaN(selectedIndex) || selectedIndex < 0 || !tokenList[selectedIndex]) { return null; } return tokenList[selectedIndex]; }


        // --- Bot Control ---
        // [ --- MODIFIED: `startBot` initializes and saves budget --- ]
        async function startBot() { 
            if (!userAccount) { logMessage("Please log in before starting the bot.", "error"); return; } 
            if (isBotRunning) return; 
            currentMarket = { id: null, type: null }; 
            marketConfig = { baseContract: null, quoteContract: null, isInverted: false }; 

            const selectedStrategy = strategySelect.value;
            
            // Timeframe check for Short Term
            if (selectedStrategy === 'short-term' && timeframeSelect.value !== '1') {
                logMessage("Short Term Strategies require the '1 Minute' timeframe to be selected. Bot not started.", "error");
                return;
            }

            // [ --- NEW: Initialize Budget on Start --- ]
            const initialA = parseFloat(budgetTokenA.value) || 0;
            const initialB = parseFloat(budgetTokenB.value) || 0;
            
            // Only reset spent amounts if the budget itself has changed or wasn't set before
            if (budgetState.initialA !== initialA || budgetState.initialB !== initialB) {
                 logMessage("Initializing budget...", "system");
                 budgetState.initialA = initialA;
                 budgetState.initialB = initialB;
                 budgetState.spentA = 0.0; // Reset spent amount on new budget
                 budgetState.spentB = 0.0; // Reset spent amount on new budget
                 budgetState.enabled = (initialA > 0 || initialB > 0);
                 saveBudgetState();
                 updateBudgetDisplay();
                 logMessage(`Budget ${budgetState.enabled ? 'enabled' : 'disabled'}. A: ${initialA}, B: ${initialB}`, "system");
            } else {
                // Keep existing spent amounts if budget hasn't changed
                 budgetState.enabled = (budgetState.initialA > 0 || budgetState.initialB > 0);
                 logMessage(`Using existing budget. Enabled: ${budgetState.enabled}`, "system");
                 updateBudgetDisplay(); // Ensure display is correct
            }
             
            // Range Trading Pre-Check
            if (selectedStrategy === 'range-trading') {
                 logMessage("Range Trading: Performing pre-start check...", "system");
                 const lower = parseFloat(rangeLower.value);
                 const upper = parseFloat(rangeUpper.value);
                 if (isNaN(lower) || isNaN(upper) || lower <= 0 || upper <= 0 || lower >= upper) {
                    logMessage("Range Trading: Invalid Lower/Upper bounds set. Bot not started.", "error");
                    return;
                 }
                 if (!currentMarket.id || !currentMarket.type) { 
                    const marketInfo = await findMarketId(); 
                    if (!marketInfo) { logMessage("Range Trading: Could not find market to check price. Bot not started.", "error"); return; } 
                    currentMarket = marketInfo; 
                 } 
                 const priceData = await getCurrentPrice(currentMarket.id, currentMarket.type);
                 if (!priceData) { logMessage("Range Trading: Could not fetch current price for pre-check. Bot not started.", "error"); return;}
                 
                 const currentPrice = priceData.price;
                 if (currentPrice < lower || currentPrice > upper) {
                     logMessage(`Range Trading: Current price (${currentPrice.toFixed(8)}) is OUTSIDE the defined range [${lower}, ${upper}]. Bot not started.`, "error");
                     return;
                 }
                 logMessage(`Range Trading: Pre-start check passed. Current price is within range.`, "success");
            }

            logMessage("Bot starting... Running first check.", "system"); 
            const successfulFirstRun = await runBotLogic(); 
            if (successfulFirstRun) { 
                isBotRunning = true; 
                botStatusDisplay.textContent = "RUNNING"; 
                botStatusDisplay.className = "running"; 
                startBtn.disabled = true; 
                stopBtn.disabled = false; 
                logMessage("Bot started successfully!", "success"); 
                const checkInterval = parseInt(timeframeSelect.value) * 60 * 1000; 
                botInterval = setInterval(runBotLogic, Math.max(30000, checkInterval)); 
            } else { 
                logMessage("Bot failed to start. Check contracts, symbols, and Alcor API status.", "error"); 
                // Reset budget if start failed? Maybe not, allow retry.
            } 
        }
        function stopBot(stoppedByBudget = false) { // [ --- MODIFIED: Added parameter --- ]
            if (!isBotRunning) return; 
            isBotRunning = false; 
            clearInterval(botInterval); 
            currentMarket = { id: null, type: null }; 
            marketConfig = { baseContract: null, quoteContract: null, isInverted: false }; 
            // Don't reset botState on stop for Range Trading / persistence
            
            botStatusDisplay.textContent = "STOPPED"; 
            botStatusDisplay.className = "stopped"; 
            startBtn.disabled = false; 
            stopBtn.disabled = true; 
            if (stoppedByBudget) { // Specific message if stopped by budget
                 logMessage("Bot stopped automatically due to budget limit reached.", "warn");
            } else {
                logMessage("Bot stopped manually.", "system"); 
            }
        }

        // --- Core Bot Logic ---
        // [ --- MODIFIED: `runBotLogic` includes Budget Check --- ]
        async function runBotLogic() {
            if (!isBotRunning && !userAccount) { return false; } 
            
            const tokenA = getSelectedTokenConfig('select-token-a');
            const tokenB = getSelectedTokenConfig('select-token-b');
            if (!tokenA || !tokenB) { 
                logMessage("Invalid tokens selected. Please add tokens if list is empty.", "warn"); 
                return isBotRunning;
            }
            
            logMessage("Running strategy check...", "info"); 
            
            try { 
                // --- 1. Find Market (if not already found) ---
                if (!currentMarket.id || !currentMarket.type) { 
                    const marketInfo = await findMarketId(); 
                    if (!marketInfo) { 
                        logMessage("Market could not be found or validated. Check token selections.", "error"); 
                        return isBotRunning; 
                    } 
                    currentMarket = marketInfo; 
                } 
                
                // --- 2. Get Current Price ---
                const currentPriceData = await getCurrentPrice(currentMarket.id, currentMarket.type); 
                if (!currentPriceData) { 
                    logMessage("Could not fetch current price.", "warn"); 
                    return isBotRunning; 
                } 
                const currentPrice = currentPriceData.price; 
                logMessage(`Current price: 1 ${tokenA.symbol} = ${currentPrice.toFixed(8)} ${tokenB.symbol}`, "info"); 
                lastPrices = [{ close: currentPrice }]; 
                
                 // Update Range Trading display if active
                if (strategySelect.value === 'range-trading') {
                    updateRangeStatus();
                }
                
                const selectedStrategy = strategySelect.value; 

                // --- 3. Run Strategy Logic ---
                let potentialAction = 'none'; // 'buy', 'sell', or 'none'
                let amountToSpendA = parseFloat(tradeAmountA.value); // Amount for potential sell
                let amountToSpendB = parseFloat(tradeAmountB.value); // Amount for potential buy

                // --- Determine potential action based on strategy ---
                
                // --- 3A. Price Range Strategy (One-way) ---
                if (selectedStrategy === 'price-range') { 
                    const lowerBuyPrice = parseFloat(priceLower.value); 
                    const upperSellPrice = parseFloat(priceUpper.value); 
                    if (isNaN(lowerBuyPrice) || isNaN(upperSellPrice) || lowerBuyPrice <= 0 || upperSellPrice <= 0) { logMessage("Price Range: Please set a valid lower and upper price.", "warn"); return true; } 
                    
                    if (!botState.inPosition && currentPrice <= lowerBuyPrice) { potentialAction = 'buy'; } 
                    else if (currentPrice >= upperSellPrice) { potentialAction = 'sell'; } // Allow sell even if in position from another strategy? Yes.
                
                // --- 3B. RSI Strategy (One-way) ---
                } else if (selectedStrategy === 'rsi') { 
                     const prices = await getPriceHistory(currentMarket.id); 
                    if (!prices || prices.length < 14) { logMessage("RSI: Not enough historical data. Skipping check.", "warn"); return true; } 
                    const closePrices = prices.map(p => p.close); 
                    const rsiValues = tw.rsi(closePrices, 14); 
                    const currentRSI = rsiValues[rsiValues.length - 1]; 
                    logMessage(`Current RSI: ${currentRSI.toFixed(2)}`, "info"); 
                    const buyLevel = parseFloat(rsiBuy.value); 
                    const sellLevel = parseFloat(rsiSell.value); 
                    if (!botState.inPosition && currentRSI <= buyLevel) { potentialAction = 'buy'; } 
                    else if (currentRSI >= sellLevel) { potentialAction = 'sell'; }
                
                // --- 3C. Short Term Strategy Bundle ---
                } else if (selectedStrategy === 'short-term') {
                     // Get historical data needed by both sub-strategies
                     const subStrategy = shortTermStrategySelect.value;
                     const fastPeriod = parseInt(emaFast.value);
                     const slowPeriod = parseInt(emaSlow.value);
                     const avgCandles = parseInt(volAvgCandles.value);
                     const trendEmaPeriod = parseInt(volTrendEma.value);
                     const requiredCandles = Math.max(slowPeriod, avgCandles + 1, trendEmaPeriod);
                     const prices = await getPriceHistory(currentMarket.id);

                     if (!prices || prices.length < requiredCandles) {
                         logMessage(`Short Term: Not enough historical data. Need ${requiredCandles} candles, got ${prices ? prices.length : 0}.`, "warn");
                         return true; // Wait for more data
                     }
                     const closePrices = prices.map(p => p.close);

                    // --- Check SELL ---
                    if (botState.inPosition) {
                        if (botState.strategy === 'volume-spike') {
                            const takeProfit = parseFloat(volTakeProfit.value);
                            const stopLoss = parseFloat(volStopLoss.value);
                            const takeProfitPrice = botState.buyPrice * (1 + (takeProfit / 100));
                            const stopLossPrice = botState.buyPrice * (1 - (stopLoss / 100));
                            if (currentPrice >= takeProfitPrice || currentPrice <= stopLossPrice) { potentialAction = 'sell'; }
                        } else if (botState.strategy === 'ema-crossover') {
                            const fastEMAs = tw.ema(closePrices, fastPeriod);
                            const slowEMAs = tw.ema(closePrices, slowPeriod);
                            if (fastEMAs.length >= 2 && slowEMAs.length >=2) { // Need previous values
                                const currentFast = fastEMAs[fastEMAs.length - 1];
                                const prevFast = fastEMAs[fastEMAs.length - 2];
                                const currentSlow = slowEMAs[slowEMAs.length - 1];
                                const prevSlow = slowEMAs[slowEMAs.length - 2];
                                if (prevFast >= prevSlow && currentFast < currentSlow) { potentialAction = 'sell'; }
                            }
                        }
                    // --- Check BUY ---
                    } else {
                        if (subStrategy === 'volume-spike') {
                            const multiplier = parseFloat(volMultiplier.value);
                            const lastCandle = prices[prices.length - 1];
                            const historySlice = prices.slice(prices.length - 1 - avgCandles, prices.length - 1);
                            const totalVolume = historySlice.reduce((acc, c) => acc + c.volume, 0);
                            const avgVolume = historySlice.length > 0 ? totalVolume / historySlice.length : 0;
                            const isVolumeSpike = lastCandle.volume > (avgVolume * multiplier);
                            const isPriceUp = lastCandle.close > lastCandle.open; 
                            let isUptrend = true; 
                            if (trendEmaPeriod > 0) {
                                const trendEMAs = tw.ema(closePrices, trendEmaPeriod);
                                const currentTrendEma = trendEMAs[trendEMAs.length - 1];
                                isUptrend = lastCandle.close > currentTrendEma;
                            }
                            let signalCount = (isUptrend ? 1:0) + (isVolumeSpike ? 1:0) + (isPriceUp ? 1:0);
                            if (signalCount >= 2) { potentialAction = 'buy'; }
                        } else if (subStrategy === 'ema-crossover') {
                             const fastEMAs = tw.ema(closePrices, fastPeriod);
                             const slowEMAs = tw.ema(closePrices, slowPeriod);
                             if (fastEMAs.length >= 2 && slowEMAs.length >= 2) {
                                const currentFast = fastEMAs[fastEMAs.length - 1];
                                const prevFast = fastEMAs[fastEMAs.length - 2];
                                const currentSlow = slowEMAs[slowEMAs.length - 1];
                                const prevSlow = slowEMAs[slowEMAs.length - 2];
                                if (prevFast <= prevSlow && currentFast > currentSlow) { potentialAction = 'buy'; }
                            }
                        }
                    }
                
                 // --- 3D. Range Trading Strategy ---
                } else if (selectedStrategy === 'range-trading') {
                     const lowerBound = parseFloat(rangeLower.value);
                     const upperBound = parseFloat(rangeUpper.value);
                     if (isNaN(lowerBound) || isNaN(upperBound) || lowerBound <= 0 || upperBound <= 0 || lowerBound >= upperBound) { logMessage("Range Trading: Invalid Lower/Upper bounds set.", "warn"); return true; } 
                     
                     if (!botState.inPosition && currentPrice <= lowerBound) { potentialAction = 'buy'; } 
                     else if (botState.inPosition && botState.strategy === 'range-trading' && currentPrice >= upperBound) { potentialAction = 'sell'; }
                }

                // --- 4. [NEW] Budget Check ---
                if (potentialAction !== 'none' && budgetState.enabled) {
                    if (potentialAction === 'buy') {
                        const requiredBudgetB = amountToSpendB;
                        const availableBudgetB = budgetState.initialB - budgetState.spentB;
                        if (requiredBudgetB > availableBudgetB) {
                            logMessage(`BUDGET CHECK FAILED (BUY): Required ${requiredBudgetB.toFixed(4)} ${tokenB.symbol}, but only ${availableBudgetB.toFixed(4)} of initial budget remaining.`, "error");
                            stopBot(true); // Stop the bot due to budget
                            return false; // Stop this execution cycle
                        }
                        logMessage(`Budget Check (BUY): OK. Required: ${requiredBudgetB.toFixed(4)}, Available: ${availableBudgetB.toFixed(4)} ${tokenB.symbol}`, "system");
                    } else if (potentialAction === 'sell') {
                        const requiredBudgetA = amountToSpendA; // This is the amount of Token A we are spending/selling
                        const availableBudgetA = budgetState.initialA - budgetState.spentA;
                         if (requiredBudgetA > availableBudgetA) {
                            logMessage(`BUDGET CHECK FAILED (SELL): Required ${requiredBudgetA.toFixed(4)} ${tokenA.symbol}, but only ${availableBudgetA.toFixed(4)} of initial budget remaining.`, "error");
                            stopBot(true); // Stop the bot due to budget
                            return false; // Stop this execution cycle
                        }
                         logMessage(`Budget Check (SELL): OK. Required: ${requiredBudgetA.toFixed(4)}, Available: ${availableBudgetA.toFixed(4)} ${tokenA.symbol}`, "system");
                    }
                }

                // --- 5. Execute Action if Budget Allows ---
                if (potentialAction === 'buy') {
                    // Log the trigger reason based on strategy
                     logTriggerMessage(selectedStrategy, 'buy', currentPrice, botState);
                     const bought = await executeSwap('buy', amountToSpendA, amountToSpendB); // Pass amounts to executeSwap
                     if (bought) { 
                         // Update state based on strategy
                         if (selectedStrategy === 'short-term') botState.buyPrice = currentPrice; // Only needed for TP/SL
                         else if (selectedStrategy === 'range-trading') botState.buyPrice = currentPrice;
                         
                         botState.inPosition = true; 
                         botState.strategy = selectedStrategy; // Store strategy used to buy
                         if (selectedStrategy === 'short-term') botState.strategy = shortTermStrategySelect.value; // Store sub-strategy
                         
                         saveBotState(); 
                     }
                } else if (potentialAction === 'sell') {
                     // Log the trigger reason based on strategy
                     logTriggerMessage(selectedStrategy, 'sell', currentPrice, botState);
                     const sold = await executeSwap('sell', amountToSpendA, amountToSpendB); // Pass amounts to executeSwap
                     if (sold) {
                         // Reset state if the sell corresponds to a strategy's exit rule
                          if ( (selectedStrategy === 'short-term' && botState.inPosition && botState.strategy === shortTermStrategySelect.value) || // Sold based on short-term exit
                               (selectedStrategy === 'range-trading' && botState.inPosition && botState.strategy === 'range-trading') // Sold based on range exit
                             ) {
                             botState.inPosition = false;
                             botState.buyPrice = 0.0;
                             botState.strategy = null;
                             saveBotState();
                         }
                         // For RSI and PriceRange, selling doesn't depend on being 'inPosition' via the bot state, so no state reset needed here.
                     }
                } else {
                     logNoTriggerMessage(selectedStrategy, botState);
                }
                
                return true; // Indicate successful run
            } catch (e) { 
                logMessage(`Error in bot logic: ${e.message}`, "error"); 
                currentMarket = { id: null, type: null }; 
                marketConfig = { baseContract: null, quoteContract: null, isInverted: false }; 
                return false; // Indicate failed run
            } 
        }
        
        // [ --- NEW: Helper functions to log trigger/no trigger reasons --- ]
        function logTriggerMessage(strategy, direction, price, state) {
             let msg = '';
             if (strategy === 'price-range') msg = direction === 'buy' ? `PRICE BUY TRIGGER! Price (${price.toFixed(8)}) <= Lower Bound.` : `PRICE SELL TRIGGER! Price (${price.toFixed(8)}) >= Upper Bound.`;
             else if (strategy === 'rsi') msg = direction === 'buy' ? `RSI BUY TRIGGER!` : `RSI SELL TRIGGER!`; // Specific RSI value logged elsewhere
             else if (strategy === 'short-term') {
                 if (direction === 'buy') {
                     if (state.strategy === 'volume-spike') msg = `VOLUME SPIKE BUY TRIGGER!`; // Details logged elsewhere
                     else if (state.strategy === 'ema-crossover') msg = `EMA CROSSOVER BUY TRIGGER!`; // Details logged elsewhere
                 } else { // Sell triggers
                     if (state.strategy === 'volume-spike') msg = `TAKE PROFIT / STOP LOSS TRIGGER!`; // Details logged elsewhere
                     else if (state.strategy === 'ema-crossover') msg = `EMA CROSSOVER SELL TRIGGER!`; // Details logged elsewhere
                 }
             }
             else if (strategy === 'range-trading') msg = direction === 'buy' ? `RANGE BUY TRIGGER! Price (${price.toFixed(8)}) <= Lower Bound.` : `RANGE SELL TRIGGER! Price (${price.toFixed(8)}) >= Upper Bound.`;
             
             if (msg) logMessage(msg, "success");
        }
        
        function logNoTriggerMessage(strategy, state) {
            let msg = '';
             if (strategy === 'price-range') msg = `Price Range: No trigger.`;
             else if (strategy === 'rsi') msg = `RSI: No trigger.`;
             else if (strategy === 'short-term') {
                 const subStrategy = shortTermStrategySelect.value;
                 if (state.inPosition) {
                      if (state.strategy === 'volume-spike') msg = `Vol Spike: Holding position. Price is between TP and SL.`;
                      else if (state.strategy === 'ema-crossover') msg = `EMA Crossover: Holding position. No sell crossover detected.`;
                 } else {
                      if (subStrategy === 'volume-spike') msg = `Volume Spike: No trigger.`; // Details logged elsewhere
                      else if (subStrategy === 'ema-crossover') msg = `EMA Crossover: No buy crossover detected.`;
                 }
             }
             else if (strategy === 'range-trading') msg = state.inPosition ? `Range Trading: Holding position.` : `Range Trading: Waiting for price to hit bounds.`;
             
             if(msg) logMessage(msg, "info");
        }
        
        async function findMarketId() {
            const tokenA = getSelectedTokenConfig('select-token-a');
            const tokenB = getSelectedTokenConfig('select-token-b');
            if (!tokenA || !tokenB) { logMessage("Please select valid tokens from the dropdowns.", "error"); return null; }
            if (tokenA.contract === tokenB.contract && tokenA.symbol === tokenB.symbol) { logMessage("Token A and Token B cannot be the same token.", "error"); return null; }
            const tokenA_contract = tokenA.contract.toLowerCase();
            const tokenA_symbol = tokenA.symbol.toUpperCase();
            const tokenB_contract = tokenB.contract.toLowerCase();
            const tokenB_symbol = tokenB.symbol.toUpperCase();
            logMessage(`Searching for market ${tokenA_symbol}@${tokenA_contract} / ${tokenB_symbol}@${tokenB_contract}...`, "system");
            let foundMarketInfo = null; 
            try {
                const url = `${ALCOR_API}/swap/pools`; 
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Swap API failed (${response.status})`);
                const swapMarkets = await response.json();
                const foundSwapMarket = swapMarkets.find(m => (m.tokenA.contract === tokenA_contract && m.tokenA.symbol === tokenA_symbol && m.tokenB.contract === tokenB_contract && m.tokenB.symbol === tokenB_symbol) || (m.tokenA.contract === tokenB_contract && m.tokenA.symbol === tokenB_symbol && m.tokenB.contract === tokenA_contract && m.tokenB.symbol === tokenA_symbol));
                if (foundSwapMarket && foundSwapMarket.id > 0) { 
                    logMessage(`Found SWAP market (LP). ID: ${foundSwapMarket.id}`, "success");
                    let base_contract, base_symbol, quote_contract, quote_symbol;
                    if (foundSwapMarket.tokenA.contract === tokenA_contract && foundSwapMarket.tokenA.symbol === tokenA_symbol) { base_contract = foundSwapMarket.tokenA.contract; base_symbol = foundSwapMarket.tokenA.symbol; quote_contract = foundSwapMarket.tokenB.contract; quote_symbol = foundSwapMarket.tokenB.symbol; } else { base_contract = foundSwapMarket.tokenB.contract; base_symbol = foundSwapMarket.tokenB.symbol; quote_contract = foundSwapMarket.tokenA.contract; quote_symbol = foundSwapMarket.tokenA.symbol; }
                    foundMarketInfo = { id: foundSwapMarket.id, type: 'swap', base_contract, base_symbol, quote_contract, quote_symbol };
                } else if (foundSwapMarket && foundSwapMarket.id === 0) {
                     logMessage(`Found SWAP market but ID is 0. Treating as invalid.`, "warn");
                } else {
                     logMessage("Did not find a valid (>0) SWAP market (LP) matching both contract and symbol.", "info");
                }
            } catch (e) { logMessage(`Could not check swap (LP) markets: ${e.message}`, "warn"); }

            if (!foundMarketInfo) {
                logMessage("No valid SWAP (LP) pool found, checking SPOT markets as fallback...", "system");
                try {
                    const url = `${ALCOR_API}/markets`; 
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Spot API failed (${response.status})`);
                    const spotMarkets = await response.json();
                    const foundSpotMarket = spotMarkets.find(m => (m.base_token.contract === tokenA_contract && m.base_token.symbol.name === tokenA_symbol && m.quote_token.contract === tokenB_contract && m.quote_token.symbol.name === tokenB_symbol) || (m.base_token.contract === tokenB_contract && m.base_token.symbol.name === tokenB_symbol && m.quote_token.contract === tokenA_contract && m.quote_token.symbol.name === tokenA_symbol));
                    if (foundSpotMarket && foundSpotMarket.id > 0) { 
                        logMessage(`Found SPOT market (using as fallback). ID: ${foundSpotMarket.id}`, "success");
                         foundMarketInfo = { id: foundSpotMarket.id, type: 'spot', base_contract: foundSpotMarket.base_token.contract, base_symbol: foundSpotMarket.base_token.symbol.name, quote_contract: foundSpotMarket.quote_token.contract, quote_symbol: foundSpotMarket.quote_token.symbol.name };
                    } else {
                         logMessage("Did not find a valid (>0) SPOT market matching both contract and symbol.", "info");
                    }
                } catch (e) { logMessage(`Could not check spot markets: ${e.message}`, "warn"); }
            }
            
            if (foundMarketInfo) {
                marketConfig.baseContract = foundMarketInfo.base_contract;
                marketConfig.quoteContract = foundMarketInfo.quote_contract;
                marketConfig.isInverted = !(foundMarketInfo.base_contract === tokenA_contract && foundMarketInfo.base_symbol === tokenA_symbol); 
                logMessage(`Validated Market: ID ${foundMarketInfo.id} (Type: ${foundMarketInfo.type}). Base: ${marketConfig.baseContract} (${foundMarketInfo.base_symbol}), Quote: ${marketConfig.quoteContract} (${foundMarketInfo.quote_symbol}), Inverted (relative to input A): ${marketConfig.isInverted}`, "system");
                return { id: foundMarketInfo.id, type: foundMarketInfo.type }; 
            } else {
                logMessage(`No valid market found for ${tokenA_symbol}@${tokenA_contract} / ${tokenB_symbol}@${tokenB_contract}`, "error");
                return null; 
            }
        }


        async function getCurrentPrice(marketId, marketType) {
            if (!marketId || !marketType) { logMessage("Cannot get current price without market ID and type.", "error"); return null; }
            logMessage(`Fetching current price for market ${marketId} (type: ${marketType})...`, "system");
            try {
                let priceRaw; 
                if (marketType === 'spot') {
                    const url = `${ALCOR_API}/markets/${marketId}`;
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Spot Market API failed (${response.status})`);
                    const marketData = await response.json();
                    if (!marketData || typeof marketData.last_price === 'undefined') throw new Error("Spot market data invalid.");
                    priceRaw = parseFloat(marketData.last_price);
                    logMessage(`Raw spot price (Base/Quote): ${priceRaw}`, "system");
                } else if (marketType === 'swap') {
                    const url = `${ALCOR_API}/swap/pools`;
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`Swap Pools API failed (${response.status})`);
                    const swapPools = await response.json();
                    const pool = swapPools.find(p => p.id === marketId);
                    if (!pool) throw new Error(`Swap pool ${marketId} not found in list.`);
                    if (!pool.tokenA || !pool.tokenB || typeof pool.tokenA.quantity === 'undefined' || typeof pool.tokenB.quantity === 'undefined') {
                        throw new Error(`Reserve data (tokenA/tokenB quantity) missing or invalid format in pool object for ID ${marketId}. Cannot calculate price.`);
                    }
                    const reserveA = parseFloat(pool.tokenA.quantity);
                    const reserveB = parseFloat(pool.tokenB.quantity);
                    if (isNaN(reserveA) || isNaN(reserveB)) { throw new Error(`Parsed reserve values are invalid (NaN) for pool ID ${marketId}.`); }
                    logMessage(`Swap Pool (LP) Reserves: A=${reserveA}, B=${reserveB}`, "system");
                    if (pool.tokenA.contract === marketConfig.baseContract) {
                        if (reserveA === 0) { priceRaw = 0; logMessage("Warning: Base reserve (A) is 0. Price is effectively 0.", "warn"); } 
                        else { priceRaw = reserveB / reserveA; } 
                    } else {
                         if (reserveB === 0) { priceRaw = 0; logMessage("Warning: Base reserve (B) is 0. Price is effectively 0.", "warn"); }
                         else { priceRaw = reserveA / reserveB; }
                    }
                    logMessage(`Raw swap (LP) price (Base/Quote): ${priceRaw}`, "system");
                } else {
                    throw new Error(`Unknown market type: ${marketType}`);
                }
                if (marketConfig.isInverted) { 
                    if (priceRaw === 0) { logMessage("Warning: Raw price is 0, cannot calculate reciprocal. Using 0.", "warn"); return { price: 0 }; }
                    logMessage("Market is inverted relative to input. Calculating reciprocal price.", "system");
                    return { price: 1 / priceRaw };
                } else {
                    return { price: priceRaw };
                }
            } catch (e) {
                logMessage(`Failed to get current price: ${e.message}`, "error");
                return null;
            }
        }


        async function getPriceHistory(marketIdToFetch) { if (!marketIdToFetch) { logMessage("Cannot get price history without market ID.", "warn"); return null; } const timeframe = timeframeSelect.value; const now = Math.floor(Date.now() / 1000); const from = now - (60 * parseInt(timeframe) * 50); const resolution = timeframe; const url = `${ALCOR_API}/charts/history?market=${marketIdToFetch}&resolution=${resolution}&from=${from}&to=${now}`; logMessage(`Fetching price history for ${timeframe}m (ID: ${marketIdToFetch})...`, "system"); try { const response = await fetch(url); if (!response.ok) { if (response.status === 404) { logMessage(`No price history found for market ${marketIdToFetch} at ${timeframe}m resolution.`, "warn"); return null; } throw new Error(`History API failed (${response.status})`); } const data = await response.json(); if (!data || data.length === 0) { logMessage("No price history data returned from Alcor.", "warn"); return null; } if (marketConfig.isInverted) { logMessage("History: Market is inverted. Inverting prices.", "system"); return data.map(d => ({ time: d.time, open: d.open ? 1 / d.open : 0, high: d.low ? 1 / d.low : 0, low: d.high ? 1 / d.high : 0, close: d.close ? 1 / d.close : 0, volume: d.volume * (d.close || 0) })).filter(d => isFinite(d.open) && isFinite(d.high) && isFinite(d.low) && isFinite(d.close)); } else { return data.map(d => ({ time: d.time, open: parseFloat(d.open || 0), high: parseFloat(d.high || 0), low: parseFloat(d.low || 0), close: parseFloat(d.close || 0), volume: parseFloat(d.volume || 0) })).filter(d => isFinite(d.open) && isFinite(d.high) && isFinite(d.low) && isFinite(d.close)); } } catch (e) { logMessage(`Failed to get price history: ${e.message}`, "error"); return null; } }

        
        // [ --- MODIFIED: `executeSwap` updates budget state --- ]
        async function executeSwap(direction, amountA_intended, amountB_intended) { // Pass intended amounts
            logMessage(`Attempting to execute ${direction.toUpperCase()} swap...`, "system"); 
            try {
                const tokenA = getSelectedTokenConfig('select-token-a');
                const tokenB = getSelectedTokenConfig('select-token-b');
                if (!tokenA || !tokenB) { logMessage("Selected tokens are invalid. Cannot execute swap.", "error"); return false; }
                
                // Use intended amounts passed from runBotLogic
                const config = { 
                    aSymbol: tokenA.symbol.toUpperCase(), aContract: tokenA.contract, aDecimals: tokenA.decimals, 
                    bSymbol: tokenB.symbol.toUpperCase(), bContract: tokenB.contract, bDecimals: tokenB.decimals, 
                    dex: dexContract.value.trim(), 
                    amountA: amountA_intended, // Use passed amount
                    amountB: amountB_intended  // Use passed amount
                };
                
                if (!config.aSymbol || !config.aContract || !config.bSymbol || !config.bContract || isNaN(config.aDecimals) || isNaN(config.bDecimals) || isNaN(config.amountA) || isNaN(config.amountB) || config.amountA <= 0 || config.amountB <= 0) { logMessage("Invalid token configuration or trade amounts (in executeSwap).", "error"); return false; } 
                
                let actions = []; 
                let amountSpentA = 0; // Track actual amount spent for budget update
                let amountSpentB = 0; // Track actual amount spent for budget update

                if (direction === 'sell') { 
                    amountSpentA = config.amountA; // Selling amountA
                    const totalSellAmount = config.amountA; 
                    const feeAmount = totalSellAmount * FEE_PERCENT; 
                    const userAmount = totalSellAmount - feeAmount; 
                    if (userAmount <= 0) { logMessage("Sell amount too small for fee.", "error"); return false; } 
                    const userQuantity = `${userAmount.toFixed(config.aDecimals)} ${config.aSymbol}`; 
                    const minReturnUser = (0).toFixed(config.bDecimals); 
                    const memoUser = `swap,${minReturnUser} ${config.bSymbol},${config.bContract}`; 
                    actions.push({ account: config.aContract, name: 'transfer', authorization: [{ actor: userAccount, permission: 'active' }], data: { from: userAccount, to: config.dex, quantity: userQuantity, memo: memoUser } }); 
                    const feeQuantity = `${feeAmount.toFixed(config.aDecimals)} ${config.aSymbol}`; 
                    if (feeAmount > 0) { actions.push({ account: config.aContract, name: 'transfer', authorization: [{ actor: userAccount, permission: 'active' }], data: { from: userAccount, to: FEE_RECEIVER, quantity: feeQuantity, memo: `0.1% fee from WAX TA Trader` } }); logMessage(`ACTION (Fee): Transfer ${feeQuantity} to ${FEE_RECEIVER}`, "info"); } 
                    logMessage(`ACTION (User): Transfer ${userQuantity} to ${config.dex} | Memo: ${memoUser}`, "info"); 
                } else if (direction === 'buy') { 
                    amountSpentB = config.amountB; // Buying with amountB
                    const quantity = `${config.amountB.toFixed(config.bDecimals)} ${config.bSymbol}`; 
                    const minReturn = (0).toFixed(config.aDecimals); 
                    const memo = `swap,${minReturn} ${config.aSymbol},${config.aContract}`; 
                    actions.push({ account: config.bContract, name: 'transfer', authorization: [{ actor: userAccount, permission: 'active' }], data: { from: userAccount, to: config.dex, quantity: quantity, memo: memo } }); 
                    logMessage(`ACTION: Transfer ${quantity} to ${config.dex} | Memo: ${memo}`, "info"); 
                } 
                
                const result = await wax.api.transact({ actions }, { blocksBehind: 3, expireSeconds: 1200 }); 
                logMessage(`Swap successful! TxID: ${result.transaction_id.substring(0, 12)}...`, "success"); 
                
                 // [ --- NEW: Update Budget State on Success --- ]
                 if (budgetState.enabled) {
                     if (direction === 'buy') {
                         budgetState.spentB += amountSpentB;
                         logMessage(`Budget Updated: Spent ${amountSpentB.toFixed(4)} ${config.bSymbol}. Total Spent B: ${budgetState.spentB.toFixed(4)} / ${budgetState.initialB.toFixed(4)}`, "system");
                     } else if (direction === 'sell') {
                         budgetState.spentA += amountSpentA;
                         logMessage(`Budget Updated: Spent ${amountSpentA.toFixed(4)} ${config.aSymbol}. Total Spent A: ${budgetState.spentA.toFixed(4)} / ${budgetState.initialA.toFixed(4)}`, "system");
                     }
                     saveBudgetState();
                     updateBudgetDisplay();
                 }

                // Update PnL
                if (direction === 'buy') { 
                    updatePnl('buy', amountSpentB); // Use actual spent amount
                } else if (direction === 'sell') { 
                    if (lastPrices.length > 0) { 
                        const currentPrice = lastPrices[lastPrices.length - 1].close; 
                        const userAmountSold = amountSpentA * (1 - FEE_PERCENT); // Use actual spent amount
                        const estimatedReceivedB = userAmountSold * currentPrice; 
                        logMessage(`Est. ${estimatedReceivedB.toFixed(config.bDecimals)} ${config.bSymbol} received.`, "info"); 
                        updatePnl('sell', estimatedReceivedB); 
                    } else { 
                        logMessage(`Could not estimate PnL for sell trade, no current price data available.`, "warn"); 
                    } 
                } 
                return true;
            } catch (e) { 
                let errorMessage = e.message; 
                try { 
                    const errorJson = JSON.parse(e.message); 
                    if (errorJson.error?.details?.length > 0) errorMessage = errorJson.error.details[0].message; 
                    else if (errorJson.error?.what) errorMessage = errorJson.error.what; 
                } catch (parseError) {} 
                logMessage(`Swap failed: ${errorMessage}`, "error"); 
                return false; 
            } 
        }
    </script>
</body>
</html>
